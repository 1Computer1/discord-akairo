{"meta":{"generator":"0.8.0","format":19,"date":1553459844420},"custom":{"general":{"name":"General","files":{"welcome":{"name":"Welcome","type":"md","content":"<div align=\"center\">\n  <br />\n  <p>\n    <a href=\"https://discord-akairo.github.io\"><img src=\"https://discord-akairo.github.io/static/logo.svg\" width=\"546\" alt=\"discord-akairo\" /></a>\n  </p>\n  <br />\n  <p>\n    <a href=\"https://www.npmjs.com/package/discord-akairo\"><img src=\"https://img.shields.io/npm/v/discord-akairo.svg?maxAge=3600\" alt=\"NPM version\" /></a>\n    <a href=\"https://www.npmjs.com/package/discord-akairo\"><img src=\"https://img.shields.io/npm/dt/discord-akairo.svg?maxAge=3600\" alt=\"NPM downloads\" /></a>\n    <a href=\"https://travis-ci.org/discord-akairo/discord-akairo\"><img src=\"https://travis-ci.org/discord-akairo/discord-akairo.svg\" alt=\"Build status\" /></a>\n  </p>\n  <p>\n    <a href=\"https://nodei.co/npm/discord-akairo/\"><img src=\"https://nodei.co/npm/discord-akairo.png?downloads=true\" alt=\"npm installnfo\" /></a>\n  </p>\n</div>\n\n## Welcome!\n\nYou are currently looking at the discord-akairo v7 tutorials.\n\n## Links\n\n- [Website](https://discord-akairo.github.io)\n- [Repository](https://github.com/discord-akairo/discord-akairo)  \n- [Changelog](https://github.com/discord-akairo/discord-akairo/releases)\n- [Discord](https://discord.gg/arTauDY)  \n","path":"docs/general/welcome.md"}}},"basics":{"name":"Basics","files":{"setup":{"name":"Setting Up","type":"md","content":"# Setting Up\n\n### Installation\n\nBefore even doing anything else, you of course have to install the Discord.js and Akairo.  \n\n`npm install discord.js`  \n`npm install discord-akairo`  \n\nIf you feel like working with SQLite or Sequelize later, install that too.  \n\n`npm install sqlite`  \n`npm install sequelize`  \n\nOnce everything has been installed, your working directory should look something like this:  \n\n```\nmybot\n|____ node_modules\n      bot.js\n```\n\n### Main File\n\nInside `bot.js`, require `discord-akairo` and create your client:  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nconst client = new AkairoClient();\n\nclient.login('TOKEN');\n```\n\nThere are some options that you may want to use with your client.  \nLet's setup the owner, the prefix for commands, and the directory for commands.  \nIf you would like to have multiple owners or multiple prefixes, simply add those with an array.  \nWe want to use Discord.js's `disableEveryone` option too.  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nconst client = new AkairoClient({\n    ownerID: '123992700587343872', // or ['123992700587343872', '86890631690977280']\n    prefix: '?', // or ['?', '!']\n    commandDirectory: './commands/'\n}, {\n    disableEveryone: true\n});\n\nclient.login('TOKEN');\n```\n\nNow, your folder should look like this:  \n\n```\nmybot\n|____ node_modules\n|____ commands\n      bot.js\n```\n\nYour bot should now login, and you are ready to make commands.  \n","path":"docs/basics/setup.md"},"commands":{"name":"Basic Commands","type":"md","content":"# Basic Commands\n\n### Ping Command\n\nOur first order of business is to make a ping command.  \nNo bot is complete without one!  \n\nIn the last tutorial, we specified that the `commandDirectory` is in `./commands/`.  \nSo, go there, make a new file, and require Akairo.  \n\n```js\nconst { Command } = require('discord-akairo');\n```\n\nThere are two ways to make modules in Akairo.  \nBoth are equally valid, so choose whichever you like.  \n\n```js\n// As an instance.\n// Pro: Shorter code.\n// Con: Relies on using the `function`\n// keyword for the context of `this`.\nmodule.exports = new Command(...);\n\n// As a class.\n// Pro: Does not rely on `function`,\n// and also more easily extendable.\n// Con: Longer code.\nclass PingCommand extends Command { ... }\nmodule.exports = PingCommand;\n```\n\nIn other tutorials, we will be using the second method, as it is less confusing for use.  \nHere is a basic ping command:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PingCommand extends Command {\n    constructor() {\n        super('ping', {\n           aliases: ['ping'] \n        });\n    }\n    \n    exec(message) {\n        return message.reply('Pong!');\n    }\n}\n\nmodule.exports = PingCommand;\n```\n\nThe first parameter is the unique ID of the command.  \nIt is not seen nor used by users, but you should keep it the same as one of the aliases.  \n\nThe second parameter is the options.  \nThe only option there right now are the aliases, which are the names of the command for the users to call.  \n\nThe exec method is the execution function, ran when the command is called.  \nYou should try to always return a value such as a Promise with it, so that the framework can tell when a command finishes.  \n\nUsing the instance method, the above would look like so:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nfunction exec(message) {\n    return message.reply('Pong!');\n}\n\nmodule.exports = new Command('ping', exec, {\n    aliases: ['ping']\n});\n```\n\nIf everything was done correctly, your command should now work!  \nBecause there are a lot of things that can be changed for commands, they will be explained further in other tutorials.  \n","path":"docs/basics/commands.md"},"inhibitors":{"name":"Basic Inhibitors","type":"md","content":"# Basic Inhibitors\n\n### Setup\n\nInhibitors are a way to monitor or block messages coming into the command handler.  \nBecause inhibitors are another kind of module, we need another kind of handler.  \nTo set it up, simply add the `inhibitorDirectory` option to your client.  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nconst client = new AkairoClient({\n    ownerID: '123992700587343872',\n    prefix: '?',\n    commandDirectory: './commands/',\n    inhibitorDirectory: './inhibitors/'\n}, {\n    disableEveryone: true\n});\n\nclient.login('TOKEN');\n```\n\n### Blacklist\n\nCreate a folder named `inhibitors`, then a file there to make one.  \nJust like with commands, both an instance export and a class export works.  \nBut we will keep to an instance export because they are shorter.  \n\n```js\nconst { Inhibitor } = require('discord-akairo');\n\nclass BlacklistInhibitor extends Inhibitor {\n    constructor() {\n        super('blacklist', {\n            reason: 'blacklist'\n        })\n    }\n\n    exec(message) {\n        // He's a meanie!\n        const blacklist = ['81440962496172032'];\n        return blacklist.includes(message.author.id);\n    }\n}\n\nmodule.exports = BlacklistInhibitor;\n```\n\nThe first parameter is the unique ID of the inhibitor.  \n\nThe second parameter are the options.  \nThe option `reason` is what will get emitted to an event, but we can worry about that later.  \n\nThe exec method should return either `true`, a promise rejection, or a falsey value.  \nIf it is not a falsey value, that means the message has been blocked!  \n","path":"docs/basics/inhibitors.md"},"listeners":{"name":"Basic Listeners","type":"md","content":"# Basic Listeners\n\n### I'm Ready!\n\nListeners are a basic concept in Node.js.  \nProblem is, you usually end up with loooooong files attaching listeners on your client.  \nAnd plus, you can't reload them as easily!  \n\nLet's add some listeners.  \nYou have to setup a `listenerDirectory` just like with commands and inhibitors.  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nconst client = new AkairoClient({\n    ownerID: '123992700587343872',\n    prefix: '?',\n    commandDirectory: './commands/',\n    inhibitorDirectory: './inhibitors/',\n    listenerDirectory: './listeners/'\n}, {\n    disableEveryone: true\n});\n\nclient.login('TOKEN');\n```\n\nAnd now, we can make some!  \nLet's start with a simple client `ready` event.  \n\n```js\nconst { Listener } = require('discord-akairo');\n\nclass ReadyListener extends Listener {\n    constructor() {\n        super('ready', {\n            emitter: 'client',\n            eventName: 'ready'\n        });\n    }\n\n    exec() {\n        console.log('I\\'m ready!');\n    }\n}\n\nmodule.exports = ReadyListener;\n```\n\nThe first parameter is the listener's unique ID.  \n\nThe second parameter are the options.  \nFirst, we have the emitter's name.  \nThen, we have the event we want to listen to.  \n\nThen there is its execution function, whose parameters are the event's.  \n\nHere are the emitters that exist by default:  \n\n- `client`\n- `commandHandler`\n- `inhibitorHandler`\n- `listenerHandler`\n\n### Blocked Commands\n\nRemember the `reason` for inhibitors in previous tutorial?  \nThey are emitted to the `messageBlocked` (anything with `pre` type or before) or `commandBlocked` (everything after) event.  \n\nHere's how you would listen to them:  \n\n```js\nconst { Listener } = require('discord-akairo');\n\nclass CommandBlockedListener extends Listener {\n    constructor() {\n        super('commandBlocked', {\n            emitter: 'commandHandler',\n            eventName: 'commandBlocked'\n        });\n    }\n\n    exec(message, command, reason) {\n        console.log(`${message.author.username} was blocked from using ${command.id} because of ${reason}!`);\n    }\n}\n\nmodule.exports = CommandBlockedListener;\n```\n\nAnd if you want your listeners to run only once:  \n\n```js\nconst { Listener } = require('discord-akairo');\n\nclass CommandBlockedListener extends Listener {\n    constructor() {\n        super('commandBlocked', {\n            emitter: 'commandHandler',\n            eventName: 'commandBlocked',\n            type: 'once'\n        });\n    }\n\n    exec(message, command, reason) {\n        console.log(`${message.author.username} was blocked from using ${command.id} because of ${reason}!`);\n    }\n}\n\nmodule.exports = CommandBlockedListener;\n```\n","path":"docs/basics/listeners.md"}}},"commands":{"name":"Commands","files":{"restrictions":{"name":"Restrictions","type":"md","content":"# Restrictions\n\n### Channel Restrictions\n\nIf a command requires a guild to be used correctly, you can restrict it to a guild with one option.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass NicknameCommand extends Command {\n    constructor() {\n        super('nickname', {\n            aliases: ['nickname']\n        });\n    }\n\n    exec(message) {\n        return message.reply(`Your nickname is ${message.member.nickname}.`);\n    }\n}\n\nmodule.exports = NicknameCommand;\n```\n\nThe above breaks in a DM, so let's add the `channelRestriction` option.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass NicknameCommand extends Command {\n    constructor() {\n        super('nickname', {\n            aliases: ['nickname'],\n            channelRestriction: 'guild'\n        });\n    }\n\n    exec(message) {\n        return message.reply(`Your nickname is ${message.member.nickname}.`);\n    }\n}\n\nmodule.exports = NicknameCommand;\n```\n\nEverything is fixed and you can go on your way!  \nAs a bonus, this will emit `commandBlocked` on the command handler with the reason `guild` if someone tries to use it in a DM.  \n\n### Owner Only\n\nRemember the `ownerID` option in your client?  \nYour commands can be owner-only, restricting them to be used by the owner(s).  \nSimply add `ownerOnly`.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass TokenCommand extends Command {\n    constructor() {\n        super('token', {\n            aliases: ['token'],\n            ownerOnly: true,\n            channelRestriction: 'dm'\n        });\n    }\n\n    exec(message) {\n        // Don't actually do this.\n        return message.reply(this.client.token);\n    }\n}\n\nmodule.exports = TokenCommand;\n```\n\nThis will emit `commandBlocked` with the reason `owner` if someone else uses it.  \n","path":"docs/commands/restrictions.md"},"permissions":{"name":"Permissions","type":"md","content":"# Permissions\n\n### Permission Flags\n\nSome commands should only be used by someone with certain permissions.  \nThere are options to help you do this.  \nThe two options to use are `clientPermissions` and `userPermissions`.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass BanCommand extends Command {\n    constructor() {\n        super('ban', {\n            aliases: ['ban'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member'\n                }\n            ],\n            clientPermissions: ['BAN_MEMBERS'],\n            userPermissions: ['BAN_MEMBERS'],\n            channelRestriction: 'guild'\n        });\n    }\n\n    exec(message, args) {\n        if (!args.member) {\n            return message.reply('No member found with that name.');    \n        }\n\n        return args.member.ban().then(() => {\n            return message.reply(`${args.member} was banned!`);\n        });\n    }\n}\n\nmodule.exports = BanCommand;\n```\n\nThis now checks for the required permissions for the client, then the user.  \nJust like `channelRestriction`, it emits `commandBlocked` on the command handler.  \nThe reason is either `clientPermissions` or `userPermissions`.  \n\n### Dynamic Permissions\n\nSometimes, you may want to check for a role instead of permission flags.  \nThis means you can use a function instead of an array!  \nA function can be used on both `clientPermissions` and `userPermissions`.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass BanCommand extends Command {\n    constructor() {\n        super('ban', {\n            aliases: ['ban'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member'\n                }\n            ],\n            clientPermissions: ['BAN_MEMBERS'],\n            channelRestriction: 'guild'\n        });\n    }\n    \n    userPermissions(message) {\n        return message.member.roles.exists(role => role.name === 'Moderator');\n    }\n    \n    exec(message, args) {\n        if (!args.member) {\n            return message.reply('No member found with that name.');    \n        }\n\n        return args.member.ban().then(() => {\n            return message.reply(`${args.member} was banned!`);\n        });\n    }\n}\n\nmodule.exports = BanCommand;\n```\n","path":"docs/commands/permissions.md"},"cooldowns":{"name":"Cooldowns","type":"md","content":"# Cooldowns\n\n### No Spam!\n\nCooldowns are how you make sure that troublemakers don't spam your bot.  \nAkairo allows you to set cooldowns in uses per milliseconds.  \n\n```js\nconst { Command } = require('discord-akairo');\nconst exampleAPI = require('example-api');\n\nclass RequestCommand extends Command {\n    constructor() {\n        super('request', {\n            aliases: ['request'],\n            cooldown: 10000,\n            ratelimit: 2\n        });\n    }\n\n    exec(message) {\n        return exampleAPI.fetchInfo().then(info => {\n            return message.reply(info);\n        });\n    }\n}\n\nmodule.exports = RequestCommand;\n```\n\n`cooldown` is the amount of time a user would be in cooldown for.  \n`ratelimit` is the amount of uses a user can do before they are denied usage.  \n\nIn simple terms, this means 2 uses every 10000 milliseconds.  \n\nIf you wish to set a default cooldown for all commands, the `defaultCooldown` option is available:  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nconst client = new AkairoClient({\n    ownerID: '123992700587343872',\n    prefix: '?',\n    defaultCooldown: 1000,\n    commandDirectory: './commands/',\n    inhibitorDirectory: './inhibitors/',\n    listenerDirectory: './listeners/'\n}, {\n    disableEveryone: true\n});\n\nclient.login('TOKEN');\n```\n\nWhen someone uses a command while in cooldown, the event `commandCooldown` will be emitted on the command handler with the remaining time in milliseconds.  \n","path":"docs/commands/cooldowns.md"},"regex":{"name":"Regex Commands","type":"md","content":"# Regex Commands\n\n### Memes\n\nRegex or regular expressions, is basically a way to match characters in a string.  \nCommands can be triggered with regular expressions using the `trigger` option.  \nMultiple regex commands/conditional can be triggered from one message.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AyyCommand extends Command {\n    constructor() {\n        super('ayy', {\n            trigger: /^ayy$/i\n        });\n    }\n\n    exec(message, match, groups) {\n        return message.reply('lmao');\n    }\n}\n\nmodule.exports = AyyCommand;\n```\n\nThis command will trigger on any message with the content `ayy`, case-insensitive.  \nThe `match` parameter will be the result from `message.content.match(/^ayy$/i)`.  \nThe `groups` parameter will be the matched groups, if using a global regex.  \n\n### As a Function\n\nThe `trigger` option can also be a function.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AyyCommand extends Command {\n    constructor() {\n        super('ayy', {\n            category: 'random'\n        });\n    }\n\n    trigger(message) {\n        // Do some code...\n        return /^ayy$/i;\n    }\n\n    exec(message, match, groups) {\n        return message.reply('lmao');\n    }\n}\n\nmodule.exports = AyyCommand;\n```\n","path":"docs/commands/regex.md"},"conditional":{"name":"Conditional Commands","type":"md","content":"# Conditional Commands\n\n### if (commandIs('conditional', message))\n\nConditional commands are commands that run if a certain criteria is matched on a message.  \nThis is done with the `condition` option, which must be a function.  \nMultiple conditional commands/regex commands can be triggered on one message.    \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass ComplimentCommand extends Command {\n    constructor() {\n        super('compliment', {\n            category: 'random'\n        });\n    }\n\n    condition(message) {\n        return message.author.id === '126485019500871680';\n    }\n\n    exec(message) {\n        return message.reply('You are a great person!');\n    }\n}\n\nmodule.exports = ComplimentCommand;\n```\n","path":"docs/commands/conditional.md"},"prefixes":{"name":"Prefixes and Aliases","type":"md","content":"# Prefixes\n\n### Mentioning\n\nSometimes people can forget or not know the prefix for your bot, so letting them use command with a mention is useful.  \nThis can be enabled with the `allowMention` property.  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nconst client = new AkairoClient({\n    ownerID: '123992700587343872',\n    prefix: '?',\n    allowMention: true,\n    commandDirectory: './commands/',\n    inhibitorDirectory: './inhibitors/',\n    listenerDirectory: './listeners/'\n}, {\n    disableEveryone: true\n});\n\nclient.login('TOKEN');\n```\n\nNow both `?ping` and `@BOT ping` works!  \n\n### Prefix Overrides\n\nPrefix overrides are command-specific prefixes.  \nTo use them, simply add the `prefix` option.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass SecretCommand extends Command {\n    constructor() {\n        super('secret', {\n            aliases: ['secret'],\n            prefix: '???'\n        });\n    }\n\n    exec(message) {\n        return message.reply('Woah! How did you find this!?');\n    }\n}\n\nmodule.exports = SecretCommand;\n```\n\nNow, if our prefix was `?`, `?secret` won't work, but `???secret` would.  \n\nAn array works too, so you can do `prefix: ['???', '??']` and both would work.  \nLonger prefixes should be first in the list.  \nIf it was the other way around, (`['??', '???']`), `??` would be found first and `???secret` would be parsed as `??` and `?secret` instead.  \n","path":"docs/commands/prefixes.md"},"commandutil":{"name":"CommandUtil","type":"md","content":"# CommandUtil\n\n### Handling Edits\n\nThe CommandUtil class is a utility class for working with responses.  \nIn order to make it available, you must enable either `handleEdits` or `commandUtil`.  \nBecause they can use a bit of memory if there are many messages, `commandUtilLifetime` should be set.  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nconst client = new AkairoClient({\n    ownerID: '123992700587343872',\n    prefix: '?',\n    handleEdits: true,\n    commandUtil: true,\n    commandUtilLifetime: 600000,\n    commandDirectory: './commands/',\n    inhibitorDirectory: './inhibitors/',\n    listenerDirectory: './listeners/'\n}, {\n    disableEveryone: true\n});\n\nclient.login('TOKEN');\n```\n\nNow, CommandUtil is available on messages with the property `util`.  \nYou can CommandUtil methods such as `send` in order to send responses.  \nWith `handleEdits` on, the `send` methods will edits responses accordingly.  \nThis works for prompts as well.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass HelloCommand extends Command {\n    constructor() {\n        super('hello', {\n            aliases: ['hello']\n        });\n    }\n\n    exec(message) {\n        // Also available: util.reply()\n        return message.util.send('Hello!');\n    }\n}\n\nmodule.exports = HelloCommand;\n```\n\nAs an example of what that means:  \n\n- User sends `?ping` (message A).\n- Bot replies with `Pong!` (message B).\n- User edits message A to `?hello`.\n- Bot edits message B to `Hello!`.\n\n### Prefix and Alias\n\nCommandUtil can also be used to view the prefix and alias used.  \nThe format for command is almost always `<prefix><alias> <arguments>`.  \nSince you have the arguments for parsing already, CommandUtil stores the first two for you.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass HelloCommand extends Command {\n    constructor() {\n        super('hello', {\n            aliases: ['hello', 'hi', 'konnichiha', 'bonjour', 'heyo']\n        });\n    }\n\n    exec(message) {\n        if (message.util.alias === 'konnichiha') {\n            return message.util.send('こんにちは！');\n        }\n\n        if (message.util.alias === 'bonjour') {\n            return message.util.send('Bonjour!');\n        }\n\n        return message.util.send('Hello!');\n    }\n}\n\nmodule.exports = HelloCommand;\n```\n\nWith that, you can see which alias was used by the user.  \n\nYou can see the prefix as well.  \nFor example, if you have two prefixes, `?` and `!`, `message.util.prefix` will be either `?` or `!`.  \n\nCommandUtil, if enabled, is available on all messages just after built-in pre-inhibitors.  \nThis means an invalid input, e.g. `?not-a-command` will still be parsed with prefix of `?` and alias of `not-a-command`.  \n","path":"docs/commands/commandutil.md"}}},"arguments":{"name":"Arguments","files":{"arguments":{"name":"Basic Arguments","type":"md","content":"# Basic Arguments\n\n### Adding Numbers\n\nCommands should also have some user input, in the form of arguments.  \nIn Akairo, arguments are the most complex things ever, so this tutorial will only go through the basics.  \n\nLet's make a command that takes three numbers and adds them up.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AddCommand extends Command {\n    constructor() {\n        super('add', {\n            aliases: ['add']\n        });\n    }\n\n    exec(message) {\n        // This doesn't work!\n        return message.reply(a + b + c);\n    }\n}\n\nmodule.exports = AddCommand;\n```\n\nNow we will add arguments in the command options with the `args` option.  \nThis option must be an array of objects, containing info for parsing.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AddCommand extends Command {\n    constructor() {\n        super('add', {\n            aliases: ['add'],\n            args: [\n                {\n                    id: 'numOne',\n                    type: 'number',\n                    default: 0\n                },\n                {\n                    id: 'numTwo',\n                    type: 'number',\n                    default: 0\n                }\n                {\n                    id: 'numThree',\n                    type: 'number',\n                    default: 0\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const sum = args.numOne + args.numTwo + args.numThree;\n        return message.reply(`The sum is ${sum}!`);\n    }\n}\n\nmodule.exports = AddCommand;\n```\n\nArguments must always have an `id`, it will be what you use to refer to them in `args`.  \nThe `type` options is optional, but since we want numbers, it is set to `number`.  \nThe `default` is what is used if there are no input or no number input.  \n\n### Argument Splitting\n\nA popular feature for bots are quoted arguments.  \nBy default, arguments are not quoted, but changing it is easy.  \nLet's make a command that asks for the name, location, and age.   \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass InfoCommand extends Command {\n    constructor() {\n        super('info', {\n            aliases: ['info'],\n            split: 'quoted',\n            args: [\n                {\n                    id: 'name'\n                },\n                {\n                    id: 'location'\n                }\n                {\n                    id: 'age',\n                    type: 'number'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        return message.reply(`Hi ${args.age} years old ${args.name} from ${args.location}!`);\n    }\n}\n\nmodule.exports = InfoCommand;\n```\n\nThe `split` option determines how arguments are split into words.  \nSo now, we can input `?info \"John Smith\" \"Somewhere, Earth\" 25` and our result will be `Hi 25 years old John Smith from Somewhere, Earth!`.  \n\nOther `split` types are:  \n\n- `plain` (default) splits by whitespace, and whitespace only.\n- `split` splits the noob way, using `message.content.split(' ')` and should never be used.\n- `quoted` splits by whitespace and double quotes.\n- `sticky` splits by whitespace and double quotes, but with some minor changes.\n- `none` does not split at all, giving the entire content as one word.\n\nThe difference between `quoted` and `sticky` is this:  \nLet's take the input `!command 123\"hello world\" 456`.  \n\n- `quoted` will parse this as `['123', 'hello world', '456']`.  \n- `sticky` will parse this as `['123\"hello world\"', '456']`.  \n\nThis may seem weird, but you will see the reason later.  \n","path":"docs/arguments/arguments.md"},"matches":{"name":"Matching Input","type":"md","content":"# Matching Input\n\n### Entire Content\n\nLet's say you have a command that picks from a list inputted.  \nObviously, you won't know how many things there are.  \nSo, we need a different way of matching input instead of word by word.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PickCommand extends Command {\n    constructor() {\n        super('pick', {\n            aliases: ['pick'],\n            args: [\n                {\n                    // Only takes one word!\n                    id: 'items'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const picked = args.items; // ???\n        return message.reply(`I picked ${picked}`);\n    }\n}\n\nmodule.exports = PickCommand;\n```\n\nTo remedy this, we will use the `match` option.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PickCommand extends Command {\n    constructor() {\n        super('pick', {\n            aliases: ['pick'],\n            args: [\n                {\n                    id: 'items',\n                    match: 'content'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const items = args.items.split('|');\n        const picked = items[Math.floor(Math.random() * items.length)]\n        return message.reply(`I picked ${picked.trim()}!`);\n    }\n}\n\nmodule.exports = PickCommand;\n```\n\nNow, the entire content, excluding the prefix and command of course, is matched. \n\n### Flags\n\nIf you had a command with lots of argument that can be true or false, you may forget the order.  \nThis is where `flag` match comes in handy.  \n\nHere is a command where the user can change the output with a flag:  \n\n```js\nconst { Command } = require('discord-akairo');\nconst exampleAPI = require('example-api');\n\nclass StatsCommand extends Command {\n    constructor() {\n        super('stats', {\n            aliases: ['stats'],\n            args: [\n                {\n                    id: 'username'\n                },\n                {\n                    id: 'advanced',\n                    match: 'flag',\n                    prefix: '--advanced'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const user = exampleAPI.getUser(args.username);\n\n        if (args.advanced) {\n            return message.reply(user.advancedInfo);\n        }\n\n        return message.reply(user.basicInfo);\n    }\n}\n\nmodule.exports = StatsCommand;\n```\n\nNow, if a user does `?stats 1Computer` they will get the `basicInfo`, but if they do `?stats 1Computer --advanced`, they will get the `advancedInfo`.  \nIt can be out of order too, so `?stats --advanced 1Computer` will work.  \n\n### Prefix\n\nThe above example shows `flag`, which does only a boolean value, there or not there.  \nHere, we will use `prefix` for unordered input.  \n\nSimilar to the above example, but this time, we have many different possibilities.  \n\n```js\nconst { Command } = require('discord-akairo');\nconst exampleAPI = require('example-api');\n\nclass StatsCommand extends Command {\n    constructor() {\n        super('stats', {\n            aliases: ['stats'],\n            args: [\n                {\n                    id: 'username'\n                },\n                {\n                    id: 'color',\n                    match: 'prefix',\n                    prefix: '--color=',\n                    default: 'red'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const team = exampleAPI.getTeam(args.color);\n        const user = team.getUser(args.username);\n        \n        return message.reply(user.info);\n    }\n}\n\nmodule.exports = StatsCommand;\n```\n\nSo now, all of these inputs can be valid:  \n\n- `?stats 1Computer`\n- `?stats 1Computer --color=blue`\n- `?stats --color=green 1Computer`\n\nIf you would like to use multiple flags or prefixes, you can use an array.  \nSo, if you did `prefix: ['--color=', '--colour=']`, both will be valid for the user.  \n\n### Quoted and Sticky\n\nRemember `quoted` and `sticky`?  \nThis is where the difference is important.  \n\nWith the input `?stats 1Computer --color=\"light blue\"`:  \n\n- `quoted` gives us `{ username: '1Computer', color: '\"light' }`.\n- `sticky` gives us `{ username: '1Computer', color: 'light blue' }`.\n\nUse the one that fits for what you are doing!  \n\n### Other Match Types\n\nHere are some other match types that may be useful.  \n\n- `word` (default) matches word by word.\n- `rest` matches the rest of the content, minus things matched by `prefix` and `flag`.\n- `flag` matches a flag.\n- `prefix` matches a flag with additional input.\n- `content` matches the content.\n- `text` matches the content, minus things matched by `prefix` and `flag`.\n- `none` matches nothing at all.\n","path":"docs/arguments/matches.md"},"types":{"name":"Argument Types","type":"md","content":"# Argument Types\n\n### Basic Types\n\nAs seen in the previous tutorials, there was the `type` option for type casting.  \nYou've only seen the type `number`, so here are the rest of them:  \n\n- `string` (default)\n    - This type does not do anything.\n    - Fails if there was no input.\n- `lowercase`\n    - Transform input to all lowercase.\n    - Fails if there was no input.\n- `uppercase`\n    - Transform input to all uppercase.\n    - Fails if there was no input.\n- `charCodes`\n    - Transform the input to an array of char codes.\n    - Fails if there was no input.\n- `number`\n    - Casts to a number.\n    - Fails if input is not a number.\n- `integer`\n    - Casts to a integer.\n    - Fails if input is not a number.\n- `dynamic`\n    - Casts to a number.\n    - If not a number, does the same as `string`.\n- `dynamicInt`\n    - Casts to a integer.\n    - If not a number, does the same as `string`.\n- `url`\n    - Parses to an URL object.\n    - Fails if not a valid URL.\n- `date`\n    - Parses to a Date object.\n    - Fails if not a valid date.\n- `color`\n    - Parses a hex code to an color integer.\n    - Fails if invalid color.\n- `commandAlias`\n    - Finds a command by alias.\n    - Fails if alias does not exist.\n- `command`\n    - Finds a command by ID.\n    - Fails if no command with that ID.\n- `inhibitor`\n    - Finds an inhibitor by ID.\n    - Fails if no inhibitor with that ID.\n- `listener`\n    - Finds a listener by ID.\n    - Fails if no listener with that ID.\n\n### Discord Types\n\nOf course, since this is a framework for Discord.js, there are Discord-related types.  \n\n- `user`\n    - Resolves a user from the client's collection.\n    - Fails if it cannot find one.\n- `member`\n    - Resolves a member from the guild's collection.\n    - Fails if it cannot find one.\n- `relevant`\n    - Resolves a user from the relevant place.\n    - Works in both guilds and DMs.\n    - Fails if it cannot find one.\n- `channel`\n    - Resolves a channel from the guild's collection.\n    - Fails if it cannot find one.\n- `textChannel`\n    - Resolves a text channel from the guild's collection.\n    - Fails if it cannot find one.\n- `voiceChannel`\n    - Resolves a voice channel from the guild's collection.\n    - Fails if it cannot find one.\n- `role`\n    - Resolves a role from the guild's collection.\n    - Fails if it cannot find one.\n- `emoji`\n    - Resolves an emoji from the guild's collection.\n    - Fails if it cannot find one.\n- `guild`\n    - Resolves a guild from the client's collection.\n    - Fails if it cannot find one.\n\nAll of the above types also have plural forms.  \nSo if you do `users` instead of `user`, you will receive a Collection of resolved users.  \nThe types below are also Discord-related, but have no plural form.  \n\n- `message`\n    - Fetches a message from an ID.\n    - Fails if the fetching errored or message was not found.\n- `invite`\n    - Resolves an invite code from a link.\n    - Fails if no code could be resolved.\n- `memberMention`\n    - Matches the member from a mention.\n    - Fails if there are no members with the mention's ID.\n- `channelMention`\n    - Matches the channel from a mention.\n    - Fails if there are no channels with the mention's ID.\n- `roleMention`\n    - Matches the role from a mention.\n    - Fails if there are no roles with the mention's ID.\n- `emojiMention`\n    - Matches the emoji from a mention.\n    - Fails if there are no emojis with the mention's ID.\n    \n### Array Types\n\nThere are other ways to do type-casting instead of a string literal too.  \nThe first way is with an array:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PokemonCommand extends Command {\n    constructor() {\n        super('pokemon', {\n            aliases: ['pokemon'],\n            args: [\n                {\n                    id: 'option',\n                    type: ['grass', 'fire', 'water', 'electric'],\n                    default: 'electric'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        if (args.option === 'grass') return message.reply('bulbasaur');\n        if (args.option === 'fire') return message.reply('charmander');\n        if (args.option === 'water') return message.reply('squirtle');\n        if (args.option === 'electric') return message.reply('pikachu');\n    }\n}\n\nmodule.exports = PokemonCommand;\n```\n\nWith the above, the user can only enter one of the entries in the array.  \nIt is also case-insensitive for input, but not for output.  \nThis means that if the array was `['GrasS', 'FIrE']` and the input was `grass`, you will get `GrasS`.  \n\nYou can also do aliases with the array type like so:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PokemonCommand extends Command {\n    constructor() {\n        super('pokemon', {\n            aliases: ['pokemon'],\n            args: [\n                {\n                    id: 'option',\n                    type: [\n                        ['grass', 'leaf', 'green'],\n                        ['fire', 'red'],\n                        ['water', 'blue'],\n                        ['electric', 'electricity', 'lightning', 'yellow']\n                    ],\n                    default: 'electric'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        if (args.option === 'grass') return message.reply('bulbasaur');\n        if (args.option === 'fire') return message.reply('charmander');\n        if (args.option === 'water') return message.reply('squirtle');\n        if (args.option === 'electric') return message.reply('pikachu');\n    }\n}\n\nmodule.exports = PokemonCommand;\n```\n\nIf the user inputs anything from the arrays, the first entry will be used.  \nSo, the input of `leaf` will give you `grass`, `blue` will give you `water`, etc.  \n\n### Regex Types\n\nYou can also use a regular expression as a type.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AskCommand extends Command {\n    constructor() {\n        super('ask', {\n            aliases: ['ask'],\n            args: [\n                {\n                    id: 'yesOrNo',\n                    type: /^(yes|no)$/i\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        // {\n        //   match: [...],\n        //   groups: null\n        // }\n        console.log(args.yesOrNo);\n    }\n}\n\nmodule.exports = AskCommand;\n```\n\nThis will match `yes` or `no`, case-insensitive and `args.yesOrNo` will give you the result from `word.match(/^(yes|no)$/i`.  \nIf using a global regex, the `groups` property will be filled for matched groups.   \n","path":"docs/arguments/types.md"},"functions":{"name":"Using Functions","type":"md","content":"# Using Functions\n\n### Dynamic Defaults\n\nWhen you are doing default values for certain arguments, you could really only do what JavaScript has to offer: numbers, strings, etc.  \nWhat if we want to use a default such as the author's username or the guild's owner?  \nThis is where you can use a function.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass HighestRoleCommand extends Command {\n    constructor() {\n        super('highestRole', {\n            aliases: ['highestRole'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member',\n                    default: message => message.member\n                }\n            ],\n            channelRestriction: 'guild'\n        });\n    }\n\n    exec(message, args) {\n        return message.reply(args.member.highestRole.name);\n    }\n}\n\nmodule.exports = HighestRoleCommand;\n```\n\nThe command above gives the name of the inputted member's highest role.  \nIf there were no member or an incorrect member provided, the `default` function is called, giving us the message member.  \n\n### Dynamic Types\n\nLet's go to using a function for types.  \nTake a look at the roll command below.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass RollCommand extends Command {\n    constructor() {\n        super('roll', {\n            aliases: ['roll'],\n            args: [\n                {\n                    id: 'amount',\n                    type: 'integer',\n                    default: 100\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const res = Math.floor(Math.random() * args.amount));\n        return message.reply(`You rolled ${res}!`);\n    }\n}\n\nmodule.exports = RollCommand;\n```\n\nLet's say we want to limit the user to between 1-100, so that there are no giant numbers.  \nWhile we could do it in the execution function, let's stick it straight into the type as a function.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass RollCommand extends Command {\n    constructor() {\n        super('roll', {\n            aliases: ['roll'],\n            args: [\n                {\n                    id: 'amount',\n                    type: word => {\n                        if (!word || isNaN(word)) return null;\n                        const num = parseInt(word);\n                        if (num < 1 || num > 100) return null;\n                        return num;\n                    },\n                    default: 100\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const res = Math.floor(Math.random() * args.amount));\n        return message.reply(`You rolled ${res}!`);\n    }\n}\n\nmodule.exports = RollCommand;\n```\n\nThe type function follows these steps:  \n\n1. Check if there was input.\n2. Check if input is not a number.\n3. Parse input to an integer.\n4. Check if the integer is out of bounds.\n5. Return the integer.\n\nWhenever a `null` or `undefined` value is returned, it means the type casting failed, and the default will be used.  \nOtherwise, whatever you return is the result.  \nExcept for `true`, that will make the result the input (will be removed in a later version).  \n\nIf returning a Promise, whatever you resolve will be the result.  \nIf you reject with a non-error, it will signify a failed type cast.  \n\n### Other Functions\n\nHere are some other places you can use a function:  \n\n- As the `split` for commands.\n    - Should return an array of strings.\n- As the `match` for commands.\n    - Should return one of the match types.\n","path":"docs/arguments/functions.md"},"custom":{"name":"Custom Types","type":"md","content":"# Custom Types\n\n### Manual Build\n\nWe want to access the client's TypeResolver in order to add new types for our arguments.  \nHowever, it does not exist normally until after you call `login()`.  \nSince it would be easier to add types before login, we should build the client early.  \nThis is done with `client.build()`.  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nconst client = new AkairoClient({\n    ownerID: '123992700587343872',\n    prefix: '?',\n    commandDirectory: './commands/',\n    inhibitorDirectory: './inhibitors/',\n    listenerDirectory: './listeners/'\n}, {\n    disableEveryone: true\n});\n\n// We have access to the handlers, and therefore the type resolver, before login now!\nclient.build();\nclient.login('TOKEN');\n```\n\nNow to add a new type:  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nconst client = new AkairoClient({\n    ownerID: '123992700587343872',\n    prefix: '?',\n    commandDirectory: './commands/',\n    inhibitorDirectory: './inhibitors/',\n    listenerDirectory: './listeners/'\n}, {\n    disableEveryone: true\n});\n\nclient.build();\n\nconst pokemonList = require('./pokemon.json');\nclient.commandHandler.resolver.addType('pokemon', word => {\n    if (!word) return null;\n\n    for (const pokemon of pokemonList) {\n        if (pokemon.name.toLowerCase() === word.toLowerCase()) {\n            return pokemon;\n        }\n    }\n\n    return null;\n});\n\nclient.login('TOKEN');\n```\n\nWe now have a new type called `pokemon` which we can use in a command!  \nSimply do `type: 'pokemon'` for an argument and everything will work as expected.  \n\n### With Message\n\nLet's say we want to add a type that would get a role based on the input.  \nThis means we need access to the guild through the message.  \nGood thing the second parameter is the message!  \n\n```js\nclient.commandHandler.resolver.addType('colorRole', (word, message) => {\n    if (!word) return null;\n\n    const roles = {\n        red: '225939226628194304',\n        blue: '225939219841810432',\n        green: '225939232512802816'\n    };\n\n    const role = message.guild.roles.get(roles[word.toLowerCase()]);\n    return role || null;\n});\n```\n\nSo now, using the type `colorRole`, we can get either red, blue, or green from the input and end up with corresponding role object!  \n\n### Accessing Another Type\n\nTo get another type for use, you use the `type` method on TypeResolver.  \nThe following gives the `member` type and we can use as part of another type.  \n\n```js\nclient.commandHandler.resolver.addType('moderator', (word, message) => {\n    if (!word) return null;\n    const memberType = client.commandHandler.resolver.type('member');\n    const member = memberType(word, message);\n    if (!member.roles.has('222089067028807682')) return null;\n    return member;\n});\n```\n","path":"docs/arguments/custom.md"},"prompts":{"name":"Argument Prompting","type":"md","content":"# Argument Prompting\n\n### Please Try Again\n\nYou may notice prompting for arguments in other bots (Tatsumaki) or bot frameworks (Commando).  \nAkairo has a flexible way for you to do them too!  \nIt allows you to set the following properties:  \n\n- How many times the user can retry.\n- How long they can stall the prompt for.\n- The word to use to cancel a prompt (default is `cancel`).\n- Whether or not the prompt is optional.\n- The message to send on start, on retry, on timeout, on maximum retries, and on cancel.\n    - There can be embeds or files too!\n    - Or you can have no message at all!\n\nLet's start with a basic prompt.  \nWe will be reusing this command:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass HighestRoleCommand extends Command {\n    constructor() {\n        super('highestRole', {\n            aliases: ['highestRole'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member',\n                    default: message => message.member\n                }\n            ],\n            channelRestriction: 'guild'\n        });\n    }\n\n    exec(message, args) {\n        return message.reply(args.member.highestRole.name);\n    }\n}\n\nmodule.exports = HighestRoleCommand;\n```\n\nFirst, remove the `default`.  \nSince prompting will have the user retry until it is finished, `default` won't do anything.  \nNow, add the `prompt` property with the options you want.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass HighestRoleCommand extends Command {\n    constructor() {\n        super('highestRole', {\n            aliases: ['highestRole'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member',\n                    prompt: {\n                        start: 'Who would you like to get the highest role of?',\n                        retry: 'That\\'s not a valid member! Try again.'\n                    }\n                }\n            ],\n            channelRestriction: 'guild'\n        });\n    }\n\n    exec(message, args) {\n        return message.reply(args.member.highestRole.name);\n    }\n}\n\nmodule.exports = HighestRoleCommand;\n```\n\nSimple as that, you have a prompt.  \nGuess what, you can use a function for those messages too!  \n\n```js\nprompt: {\n    start: message => `Hey ${message.author}, who would you like to get the highest role of?`,\n    retry: message => `That\\'s not a valid member! Try again, ${message.author}.`\n}\n```\n\nAnd if you want something more complex with embeds or files, you need to return a MessageOptions object.  \nAn extra property, `content`, is available for message content.  \n\n```js\nprompt: {\n    start: message => {\n        const embed = new RichEmbed().setDescription('Please input a member!');\n        const content = 'Please!';\n        return { embed, content };\n    }\n}\n```\n\n### Cascading\n\nPrompts can also \"cascade\" from three places: the client, then the command, then the argument.  \nFor the client or the command, we would set the `defaultPrompt` option.  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nconst client = new AkairoClient({\n    ownerID: '123992700587343872',\n    prefix: '?',\n    defaultPrompt: {\n        timeout:'Time ran out, command has been cancelled.',\n        ended: 'Too many retries, command has been cancelled.',\n        cancel: 'Command has been cancelled.',\n        retries: 4,\n        time: 30000\n    },\n    commandDirectory: './commands/',\n    inhibitorDirectory: './inhibitors/',\n    listenerDirectory: './listeners/'\n}, {\n    disableEveryone: true\n});\n\nclient.login('TOKEN');\n```\n\nThose prompt options would now be applied to all prompts that do not have those options already.  \nOr, with a command with similar arguments:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AddCommand extends Command {\n    constructor() {\n        super('add', {\n            aliases: ['add'],\n            args: [\n                {\n                    id: 'numOne',\n                    type: 'number',\n                    prompt: true\n                },\n                {\n                    id: 'numTwo',\n                    type: 'number',\n                    prompt: true\n                }\n                {\n                    id: 'numThree',\n                    type: 'number',\n                    prompt: true\n                }\n            ],\n            defaultPrompt: {\n                start: 'Please input a number!',\n                retry: 'Please input a number!'\n            }\n        });\n    }\n\n    exec(message, args) {\n        const sum = args.numOne + args.numTwo + args.numThree;\n        return message.reply(`The sum is ${sum}!`);\n    }\n}\n\nmodule.exports = AddCommand;\n```\n\nRather than repeating the text for all three arguments, there is a default prompt that applies to all three.  \nTheir `prompt` property still has to be truthy in order to actually prompt, of course.  \n","path":"docs/arguments/prompts.md"},"prompts2":{"name":"More Prompting","type":"md","content":"# More Prompting\n\n### Optional Prompts\n\nOptional prompts are prompts that run if there was input, but the type casting failed.  \nIf there was no input, it would go on as normal.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass HighestRoleCommand extends Command {\n    constructor() {\n        super('highestRole', {\n            aliases: ['highestRole'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member',\n                    prompt: {\n                        start: 'Who would you like to get the highest role of?',\n                        retry: 'That\\'s not a valid member! Try again.',\n                        optional: true\n                    },\n                    default: message => message.member\n                }\n            ],\n            channelRestriction: 'guild'\n        });\n    }\n\n    exec(message, args) {\n        return message.reply(args.member.highestRole.name);\n    }\n}\n\nmodule.exports = HighestRoleCommand;\n```\n\nWith it, `default` is now used again.  \n\n- `?highestRole` would give the name for the message author.\n- `?highestRole 1Computer` would give the name for 1Computer.\n- `?highestRole someone-non-existant` would start up the prompts.\n\n### Infinite Prompts\n\nInfinite prompts are prompts that go on and on until the user says stop.  \n(You can customize the word, but by default it is `stop`.)  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PickCommand extends Command {\n    constructor() {\n        super('pick', {\n            aliases: ['pick'],\n            args: [\n                {\n                    id: 'items',\n                    match: 'none',\n                    prompt: {\n                        start: [\n                            'What items would you like to pick from?',\n                            'Type them in separate messages.',\n                            'Type `stop` when you are done.'\n                        ],\n                        infinite: true\n                    }\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const picked = args.items[Math.floor(Math.random() * items.length)]\n        return message.reply(`I picked ${picked.trim()}!`);\n    }\n}\n\nmodule.exports = PickCommand;\n```\n\nAnd with that, `args.items` is now an array of responses from the user.  \nNote that the `none` match is used, meaning nothing is matched in the original message.  \nBecause this is an infinite prompt that goes across multiple messages, we don't want it to take input from the original message.  \n","path":"docs/arguments/prompts2.md"}}},"inhibitors":{"name":"Inhibitors","files":{"inhibtypes":{"name":"Inhibitor Types","type":"md","content":"# Inhibitor Types\n\n### More Coverage\n\nRight now, your inhibitors only runs before a command.  \nThey do not actually run on all messages.  \n\nTo change that, change the `type` option.  \n\n```js\nconst { Inhibitor } = require('discord-akairo');\n\nclass BlacklistInhibitor extends Inhibitor {\n    constructor() {\n        super('blacklist', {\n            reason: 'blacklist',\n            type: 'all'\n        })\n    }\n\n    exec(message) {\n        // Still a meanie!\n        const blacklist = ['81440962496172032'];\n        return blacklist.includes(message.author.id);\n    }\n}\n\nmodule.exports = BlacklistInhibitor;\n```\n\nThere are three types:  \n\n- `all` is run on all messages.\n- `pre` is run on messages not blocked by `all` and built-in inhibitors.\n- `post` (the default) is run on messages before commands, not blocked by the previous.\n\nThe built-in inhibitors (don't worry about their names just yet) are:  \n\n- `notSelf` blocks everyone else for selfbots.\n- `client` blocks the client (itself) for non-selfbots.\n- `bot` blocks all other bots.\n- `owner` blocks non-owners from using owner-only commands.\n- `guild` blocks guild-only commands used in DMs.\n- `dm` blocks DM-only commands used in guilds.\n- `clientPermissions` blocks commands used where the client does not have permissions.\n- `userPermissions` blocks commands used where the user does not have permissions.\n\nTo make it easier to visualize, here is the order:  \n\n- `all` type inhibitors.\n- `notSelf`, `client`, and `bot`.\n- `pre` type inhibitors.\n- `owner`, `guild`, `dm`, `clientPermissions`, and `userPermissions`.\n- `post` type inhibitors.\n","path":"docs/inhibitors/inhibtypes.md"},"async":{"name":"Async Execution","type":"md","content":"# Async Execution\n\n### Promises\n\nSome inhibitors may require the use of Promises to work.  \n\n```js\nconst { Inhibitor } = require('discord-akairo');\nconst exampleAPI = require('example-api');\n\nclass BlacklistInhibitor extends Inhibitor {\n    constructor() {\n        super('gameBlacklist', {\n            reason: 'gameBlacklist'\n        });\n    }\n\n    exec(message, command) {\n        if (command.category.id !== 'games') return false;\n        return exampleAPI.fetchInfo(message.author.id).then(info => {\n            if (info.isBad) return Promise.reject();\n            return Promise.resolve();\n        });\n    }\n}\n\nmodule.exports = BlacklistInhibitor;\n```\n\nThe difference from outside of a Promise is that in order to block, you must reject.  \nAnything else is considered not a block.  \n\n### Async / Await\n\nSince Discord.js and Akairo runs on Promises, async/await is possible.  \nThe above with async/await would look like this:  \n\n```js\nconst { Inhibitor } = require('discord-akairo');\nconst exampleAPI = require('example-api');\n\nclass BlacklistInhibitor extends Inhibitor {\n    constructor() {\n        super('gameBlacklist', {\n            reason: 'gameBlacklist'\n        });\n    }\n\n    async exec(message, command) {\n        if (command.category.id !== 'games') return Promise.resolve();\n        const info = await exampleAPI.fetchInfo(message.author.id);\n\n        if (info.isBad) return Promise.reject();\n        return Promise.resolve();\n    }\n}\n\nmodule.exports = BlacklistInhibitor;\n```\n","path":"docs/inhibitors/async.md"}}},"listeners":{"name":"Listeners","files":{"emitters":{"name":"Custom Emitters","type":"md","content":"# Custom Emitters\n\n### Watching Process\n\nListeners can run on more than Akairo-related things.  \nTo add a custom emitter, use the `emitters` option on the client.  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nconst client = new AkairoClient({\n    ownerID: '123992700587343872',\n    prefix: '?',\n    emitters: {\n        process\n    },\n    commandDirectory: './commands/',\n    inhibitorDirectory: './inhibitors/',\n    listenerDirectory: './listeners/'\n}, {\n    disableEveryone: true\n});\n\nclient.login('TOKEN');\n```\n\nThe key will be the emitter's name, and the value is the emitter itself.  \nNow, we can use a listener on the process:  \n\n```js\nconst { Listener } = require('discord-akairo');\n\nclass UnhandledRejectionListener extends Listener {\n    constructor() {\n        super('unhandledRejection', {\n            eventName: 'unhandledRejection',\n            emitter: 'process'\n        });\n    }\n\n    exec(error) {\n        console.error(error);\n    }\n}\n\nmodule.exports = UnhandledRejectionListener;\n```\n","path":"docs/listeners/emitters.md"}}},"other":{"name":"Other","files":{"handling":{"name":"Handling Modules","type":"md","content":"# Handling Modules\n\n### Categorizing\n\nYou can categorize a module with the `category` option.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PingCommand extends Command {\n    constructor() {\n        super('ping', {\n            aliases: ['ping'],\n            category: 'stuff'\n        });\n    }\n\n    exec(message) {\n        return message.reply('Pong!');\n    }\n}\n\nmodule.exports = PingCommand;\n```\n\nA new category will be created on the handler with the ID of `stuff`.  \nBy default, all modules are in the `default` category.  \n\n### Reloading\n\nEverything in Akairo is a module, and all modules are loaded by handlers.  \nWith that said, this means you can add, remove, or reload modules while the bot is running!  \n\nHere is a basic command that reloads the inputted ID:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass ReloadCommand extends Command {\n    constructor() {\n        super('reload', {\n            aliases: ['reload'],\n            args: [\n                {\n                    id: 'commandID'\n                }\n            ],\n            ownerOnly: true,\n            category: 'owner'\n        });\n    }\n\n    exec(message, args) {\n        // `this` refers to the command object.\n        this.handler.reload(args.commandID);\n        return message.reply(`Reloaded command ${args.commandID}!`);\n    }\n}\n\nmodule.exports = ReloadCommand;\n```\n\nWays you can reload a module includes:  \n\n- Individually:\n    - `<AkairoHandler>.reload(moduleID)`\n    - `<AkairoModule>.reload()`\n- Many at once:\n    - `<AkairoHandler>.reloadAll()`\n    - `<Category>.reloadAll()`\n\n### Removing and Adding\n\nFor removing, simply change all those `reload` to `remove`.  \n(With the exception of `<AkairoHandler>.removeAll()`, why would you do that?!)  \n\nTo add a new module, you can either use the `add` method or the `load` method.  \n\nWith `add`, the handler will scan the specificed directory for it and look for a file with the name.  \nFor example, if you had `commands/ping.js`, you can load it by doing `<CommandHandler>.add('ping')`.  \n\nWith `load`, you will need to specify a full filepath or a module instance/class.  \nIf you load with an object, note that those cannot be reloaded.  \n","path":"docs/other/handling.md"},"handlers":{"name":"Custom Handlers","type":"md","content":"# Custom Handlers\n\n### And Custom Modules\n\nInternally, Akairo's handlers all extends AkairoHandler, and all modules extends AkairoModule.  \nSo, you can create your own handlers and module types!  \n\nCreate a new class for your module.  \n\n```js\nconst { AkairoModule } = require('discord-akairo');\n\nclass CustomModule extends AkairoModule {\n    constructor(id, exec, options) {\n        super(id, exec, options);\n\n        this.color = options.color || 'red';\n    }\n}\n\nmodule.exports = CustomModule;\n```\n\nThen, create a new class for your handler:  \n\n```js\nconst { AkairoHandler } = require('discord-akairo');\nconst CustomModule = require('./CustomModule');\n\nclass CustomHandler extends AkairoHandler {\n    constructor(client, options) {\n        super(client, options.customDirectory, CustomModule);\n\n        this.customOption = options.customOption || 'something';\n    }\n}\n\nmodule.exports = CustomHandler;\n```\n\nThe constructor parameters for the module should be obvious.  \nFor the handler, the `super()` takes the client, the directory for the handler, and the class of the module type we want to handle.  \n\nBefore we can add this handler to our client, we have to extend AkairoClient, because that's good practice.  \nWe want to override the `build()` method, because that is where the handlers get built.  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\nconst CustomHandler = require('./CustomHandler');\n\nclass CustomClient extends AkairoClient {\n    build() {\n        if (this.akairoOptions.customDirectory) {\n            this.customHandler = new CustomHandler(this, this.akairoOptions);\n        }\n\n        return super.build();\n    }\n}\n\nmodule.exports = CustomClient;\n```\n\nWe first check if a directory was passed in the options, and if so, we create our handler.  \nThen we call the super method, because that builds the default handlers.  \nYou can put the super call first if you need it in another order.  \n\nNow, although the handler is built, we do not have the modules loaded.  \nThe `loadAll()` method has to be overridden now.  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\nconst CustomHandler = require('./CustomHandler');\n\nclass CustomClient extends AkairoClient {\n    build() {\n        if (this.akairoOptions.customDirectory) {\n            this.customHandler = new CustomHandler(this, this.akairoOptions);\n        }\n\n        return super.build();\n    }\n\n    loadAll() {\n        super.loadAll();\n        if (this.customHandler) this.customHandler.loadAll();\n    }\n}\n\nmodule.exports = CustomClient;\n```\n\nNote that the super method for `loadAll()` is called first, since it may be useful to have listeners ready first.  \nSo now, we can create our custom client, with a custom handler, with a custom module type!  \n\n```js\nconst CustomClient = require('./CustomClient');\n\nconst client = new CustomClient({\n    ownerID: '123992700587343872',\n    prefix: '?',\n    customOption: 'customized',\n    commandDirectory: './commands/',\n    inhibitorDirectory: './inhibitors/',\n    listenerDirectory: './listeners/',\n    customDirectory: './customs/'\n}, {\n    disableEveryone: true\n});\n\nclient.login('TOKEN');\n```\n\nAnd the module:  \n\n```js\nconst CustomModule = require('../CustomModule');\n\nclass CustomCustom extends Custom {\n    constructor() {\n        super('custom', {\n            color: 'blue'\n        });\n    }\n\n    exec() {\n        console.log('I did something!');\n    }\n}\n\nmodule.exports = CustomCustom;\n```\n","path":"docs/other/handlers.md"},"providers":{"name":"Using Providers","type":"md","content":"# Using Providers\n\n### Storing Prefixes\n\nAkairo comes with SQLiteProvider and SequelizeProvider, optional utility classes for databases.  \nNote that if you are doing something complicated with databases, you should use SQLite or Sequelize directly.  \n\nLet's implement per-guild prefixes.  \nFirst, create a new SQLiteProvider or SequelizeProvider.  \n\n```js\nconst sqlite = require('sqlite');\nconst sequelize = require('sequelize');\n\nconst { AkairoClient, SQLiteProvider, SequelizeProvider } = require('discord-akairo');\n\nclass CustomClient extends AkairoClient {\n    constructor() {\n        super({\n            /* Options here */\n        });\n\n        // With SQLite\n        this.settings = new SQLiteProvider(sqlite.open('path/to/db.sqlite'), 'table_name', {\n            idColumn: 'guild_id',\n            dataColumn: 'settings'\n        });\n\n        // Or, with sequelize\n        this.settings = new SequelizeProvider(/* Sequelize model here */, {\n            idColumn: 'guild_id',\n            dataColumn: 'settings'\n        });\n    }\n}\n```\n\nThe providers only handle one table at a time.  \nNotice that you can set the `idColumn` and the `dataColumn`.  \n\nThe `idColumn` defaults to `id` and is the unique key for that table.  \nThe `dataColumn` is optional and will change the behavior of the provider in relation with the database.  \n\nWhen the `dataColumn` is provided, the provider will parse a single column as JSON in order to set values.  \nFor Sequelize, remember to set that column's type to JSON or JSONB.  \n\nWhen `dataColumn` is not provided, the provider will work on all columns of the table instead.  \n\nBefore you can actually use the provider, you would have to run the `init` method.  \nFor example:  \n\n```js\nclass CustomClient extends AkairoClient {\n    /* ... */\n    login(token) {\n        return this.settings.init().then(() => super.login(token));\n    }\n}\n```\n\nNow, the provider can be used like so:  \n\n```js\nclass CustomClient extends AkairoClient {\n    constructor() {\n        super({\n            prefix: message => {\n                if (message.guild) {\n                    // The third param is the default.\n                    return this.settings.get(message.guild.id, 'prefix', '!');\n                }\n\n                return '!';\n            }\n        });\n\n        /* ... */\n    }\n}\n```\n\nValues can be set with the `set` method:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PrefixCommand extends Command {\n    constructor() {\n        super('prefix', {\n            aliases: ['prefix'],\n            category: 'stuff',\n            args: [\n                {\n                    id: 'prefix',\n                    default: '!'\n                }\n            ],\n            channelRestriction: 'guild'\n        });\n    }\n\n    exec(message, args) {\n        // The third param is the default.\n        const oldPrefix = this.client.settings.get(message.guild.id, 'prefix', '!');\n\n        return this.client.settings.set(message.guild.id, 'prefix', args.prefix).then(() => {\n            return message.reply(`Prefix changed from ${oldPrefix} to ${args.prefix}`);\n        });\n    }\n}\n\nmodule.exports = PrefixCommand;\n```\n","path":"docs/other/providers.md"},"clientutil":{"name":"ClientUtil","type":"md","content":"# ClientUtil\n\n### Finding Things\n\nClientUtil is a class filled with utility methods.  \nIt is available on your client as `client.util`.  \n\nThere are three \"groups\" of resolver methods for finding or checking Discord-related things.  \nThey allow you to, for example, find a user named `1Computer` from an input of `comp`.  \n\n- `resolve <thing>`\n    - e.g. `resolveUser`, `resolveChannel`, etc.\n    - Finds an Discord-related object from a collection of those objects.\n\n- `resolve <things>`\n    - e.g. `resolveUsers`, `resolveChannels`, etc.\n    - Filters Discord-related objects from a collection of those objects.\n\n- `check <thing>`\n    - e.g. `checkUser`, `checkChannel`, etc.\n    - Used for the above methods, checks if a string could be referring to the object.\n\n### Other Methods\n\nThere are a bunch of other things you may find useful:  \n\n- `embed` and `collection`\n    - Shortcuts for RichEmbed and Collection.\n- `resolvePermissionNumber`\n    - Converts a permission number to an array of permission names.\n- `prompt` and `promptIn`\n    - Creates custom prompts.\n    - Can check reply with a regex or function.\n","path":"docs/other/clientutil.md"}}},"snippets":{"name":"Snippets","files":{"ping":{"name":"Ping Command","type":"md","content":"# Ping Command\n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PingCommand extends Command {\n    constructor() {\n        super('ping', {\n            aliases: ['ping', 'hello']\n        });\n    }\n\n    exec(message) {\n        return message.util.reply('Pong!').then(sent => {\n            const timeDiff = (sent.editedAt || sent.createdAt) - (message.editedAt || message.createdAt);\n            const text = `🔂\\u2000**RTT**: ${timeDiff} ms\\n💟\\u2000**Heartbeat**: ${Math.round(this.client.ping)} ms`;\n            return message.util.reply(`Pong!\\n${text}`);\n        });\n    }\n}\n\nmodule.exports = PingCommand;\n```\n","path":"docs/snippets/ping.md"}}}},"classes":[{"name":"Provider","description":"A provider for key-value storage.\nMust be implemented.","props":[{"name":"items","description":"Cached entries.","type":[[["Collection","<"],["string",", "],["Object",">"]]],"meta":{"line":13,"file":"Provider.js","path":"src/providers"}}],"methods":[{"name":"init","description":"Initializes the provider.","abstract":true,"returns":[[["any"]]],"meta":{"line":21,"file":"Provider.js","path":"src/providers"}},{"name":"get","description":"Gets a value.","abstract":true,"params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to get.","type":[[["string"]]]},{"name":"defaultValue","description":"Default value if not found or null.","optional":true,"type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":33,"file":"Provider.js","path":"src/providers"}},{"name":"set","description":"Sets a value.","abstract":true,"params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to set.","type":[[["string"]]]},{"name":"value","description":"The value.","type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":45,"file":"Provider.js","path":"src/providers"}},{"name":"delete","description":"Deletes a value.","abstract":true,"params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to delete.","type":[[["string"]]]}],"returns":[[["any"]]],"meta":{"line":56,"file":"Provider.js","path":"src/providers"}},{"name":"clear","description":"Clears an entry.","abstract":true,"params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]}],"returns":[[["any"]]],"meta":{"line":66,"file":"Provider.js","path":"src/providers"}}],"meta":{"line":7,"file":"Provider.js","path":"src/providers"}},{"name":"SequelizeProvider","description":"A provider using the `sequelize` library.","extends":["Provider"],"construct":{"name":"SequelizeProvider","params":[{"name":"table","description":"A Sequelize model.","type":[[["Model"]]]},{"name":"options","description":"Options to use.","optional":true,"default":"{}","type":[[["ProviderOptions"]]]}]},"props":[{"name":"table","description":"Sequelize model.","type":[[["Model"]]],"meta":{"line":17,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"idColumn","description":"Column for ID.","type":[[["string"]]],"meta":{"line":23,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"dataColumn","description":"Column for JSON data.","nullable":true,"type":[[["string"]]],"meta":{"line":29,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"items","description":"Cached entries.","type":[[["Collection","<"],["string",", "],["Object",">"]]],"meta":{"line":13,"file":"Provider.js","path":"src/providers"}}],"methods":[{"name":"init","description":"Initializes the provider.","returns":[[["Bluebird","<"],["void",">"]]],"meta":{"line":36,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"get","description":"Gets a value.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to get.","type":[[["string"]]]},{"name":"defaultValue","description":"Default value if not found or null.","optional":true,"type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":51,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"set","description":"Sets a value.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to set.","type":[[["string"]]]},{"name":"value","description":"The value.","type":[[["any"]]]}],"returns":[[["Bluebird","<"],["boolean",">"]]],"meta":{"line":67,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"delete","description":"Deletes a value.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to delete.","type":[[["string"]]]}],"returns":[[["Promise","<"],["boolean",">"]]],"meta":{"line":91,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"clear","description":"Clears an entry.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]}],"returns":[[["Bluebird","<"],["void",">"]]],"meta":{"line":113,"file":"SequelizeProvider.js","path":"src/providers"}}],"meta":{"line":9,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"SQLiteProvider","description":"A provider using the `sqlite` library.","extends":["Provider"],"construct":{"name":"SQLiteProvider","params":[{"name":"db","description":"SQLite database from `sqlite`.","type":[[["Database"]],[["Promise","<"],["Database",">"]]]},{"name":"tableName","description":"Name of table to handle.","type":[[["string"]]]},{"name":"options","description":"Options to use.","optional":true,"default":"{}","type":[[["ProviderOptions"]]]}]},"props":[{"name":"db","description":"SQLite database.","type":[[["Database"]]],"meta":{"line":18,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"tableName","description":"Name of the table.","type":[[["string"]]],"meta":{"line":24,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"idColumn","description":"Column for ID.","type":[[["string"]]],"meta":{"line":30,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"dataColumn","description":"Column for JSON data.","nullable":true,"type":[[["string"]]],"meta":{"line":36,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"items","description":"Cached entries.","type":[[["Collection","<"],["string",", "],["Object",">"]]],"meta":{"line":13,"file":"Provider.js","path":"src/providers"}}],"methods":[{"name":"init","description":"Initializes the provider.","returns":[[["Promise","<"],["void",">"]]],"meta":{"line":43,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"get","description":"Gets a value.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to get.","type":[[["string"]]]},{"name":"defaultValue","description":"Default value if not found or null.","optional":true,"type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":61,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"set","description":"Sets a value.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to set.","type":[[["string"]]]},{"name":"value","description":"The value.","type":[[["any"]]]}],"returns":[[["Promise","<"],["Statement",">"]]],"meta":{"line":77,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"delete","description":"Deletes a value.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to delete.","type":[[["string"]]]}],"returns":[[["Promise","<"],["Statement",">"]]],"meta":{"line":107,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"clear","description":"Clears an entry.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]}],"returns":[[["Promise","<"],["Statement",">"]]],"meta":{"line":129,"file":"SQLiteProvider.js","path":"src/providers"}}],"meta":{"line":10,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"AkairoClient","description":"The Akairo framework client.\nCreates the handlers and sets them up.","construct":{"name":"AkairoClient","params":[{"name":"options","description":"Options to use for the framework.","optional":true,"default":"{}","type":[[["AkairoOptions"]]]},{"name":"clientOptions","description":"Options for Discord JS client.\nIf not specified, the previous options parameter is used instead.","optional":true,"type":[[["ClientOptions"]]]}]},"props":[{"name":"ownerID","description":"The ID of the owner.","type":[[["string"]]],"meta":{"line":22,"file":"AkairoClient.js","path":"src/struct"}},{"name":"selfbot","description":"Whether or not this is a selfbot.","type":[[["boolean"]]],"meta":{"line":28,"file":"AkairoClient.js","path":"src/struct"}},{"name":"mem","description":"An empty object.\nUseful for storing things.","deprecated":"Extend the class","type":[[["Object"]]],"meta":{"line":39,"file":"AkairoClient.js","path":"src/struct"}},{"name":"util","description":"Utility methods.","type":[[["ClientUtil"]]],"meta":{"line":45,"file":"AkairoClient.js","path":"src/struct"}},{"name":"databases","description":"Databases added.","deprecated":"Use providers","type":[[["Object"]]],"meta":{"line":52,"file":"AkairoClient.js","path":"src/struct"}},{"name":"akairoOptions","description":"Options for the framework.","type":[[["AkairoOptions"]]],"meta":{"line":58,"file":"AkairoClient.js","path":"src/struct"}},{"name":"commandHandler","description":"The command handler.","type":[[["CommandHandler"]]],"meta":{"line":141,"file":"AkairoClient.js","path":"src/struct"}},{"name":"inhibitorHandler","description":"The inhibitor handler.","type":[[["InhibitorHandler"]]],"meta":{"line":149,"file":"AkairoClient.js","path":"src/struct"}},{"name":"listenerHandler","description":"The listener handler.","type":[[["ListenerHandler"]]],"meta":{"line":157,"file":"AkairoClient.js","path":"src/struct"}}],"methods":[{"name":"addDatabase","description":"Adds a database that will be initialized once ready.","deprecated":"Use providers","params":[{"name":"name","description":"Name of database.","type":[[["string"]]]},{"name":"database","description":"The database.","type":[[["SQLiteHandler"]]]}],"returns":[[["AkairoClient"]]],"meta":{"line":71,"file":"AkairoClient.js","path":"src/struct"}},{"name":"login","description":"Logins the client, creates message listener, and initialize databases.\nResolves once client is ready.","params":[{"name":"token","description":"Client token.","type":[[["string"]]]}],"returns":[[["Promise","<"],["string",">"]]],"meta":{"line":89,"file":"AkairoClient.js","path":"src/struct"}},{"name":"build","description":"Builds the client by creating the handlers.","returns":[[["AkairoClient"]]],"meta":{"line":129,"file":"AkairoClient.js","path":"src/struct"}},{"name":"loadAll","description":"Calls `loadAll()` on the handlers.","returns":[[["void"]]],"meta":{"line":167,"file":"AkairoClient.js","path":"src/struct"}}],"meta":{"line":14,"file":"AkairoClient.js","path":"src/struct"}},{"name":"AkairoHandler","description":"Base class for handling modules.","extends":["EventEmitter"],"construct":{"name":"AkairoHandler","params":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]]},{"name":"directory","description":"Directory to modules.","type":[[["string"]]]},{"name":"classToHandle","description":"Only instances of this can be handled.\nExports not instance of this class are ignored.","type":[[["class"]]]}]},"props":[{"name":"client","description":"The Akairo client.","readonly":true,"type":[[["AkairoClient"]]],"meta":{"line":23,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"directory","description":"Directory to modules.","readonly":true,"type":[[["string"]]],"meta":{"line":30,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"classToHandle","description":"Class to handle.","readonly":true,"type":[[["function"]]],"meta":{"line":37,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"modules","description":"Modules loaded, mapped by ID to AkairoModule.","type":[[["Collection","<"],["string",", "],["AkairoModule",">"]]],"meta":{"line":60,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"categories","description":"Categories, mapped by ID to Category.","type":[[["Collection","<"],["string",", "],["Category",">"]]],"meta":{"line":66,"file":"AkairoHandler.js","path":"src/struct"}}],"methods":[{"name":"loadAll","description":"Reads all modules from the directory and loads them.","returns":[[["AkairoHandler"]]],"meta":{"line":73,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"_apply","description":"Registers a module.","access":"private","params":[{"name":"mod","description":"Module to use.","type":[[["AkairoModule"]]]},{"name":"filepath","description":"Filepath of module.","optional":true,"type":[[["string"]]]}],"returns":[[["void"]]],"meta":{"line":86,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"_unapply","description":"Deregisters a module.","access":"private","params":[{"name":"mod","description":"Module to use.","type":[[["AkairoModule"]]]}],"returns":[[["void"]]],"meta":{"line":118,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"load","description":"Loads a module, can be a filepath or an object.","params":[{"name":"thing","description":"Module or path to module.","type":[[["string"]],[["AkairoModule"]]]},{"name":"isReload","description":"Whether this is a reload or not.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":130,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"add","description":"Adds a module.","deprecated":"Use AkairoHandler#load","params":[{"name":"filename","description":"Filename to lookup in the directory.\nA .js extension is assumed.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":169,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"remove","description":"Removes a module.","params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":185,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"removeAll","description":"Removes all modules.","returns":[[["AkairoHandler"]]],"meta":{"line":199,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reload","description":"Reloads a module.","params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":212,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reloadAll","description":"Reloads all modules.","returns":[[["AkairoHandler"]]],"meta":{"line":230,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"findCategory","description":"Finds a category by name.","params":[{"name":"name","description":"Name to find with.","type":[[["string"]]]}],"returns":[[["Category"]]],"meta":{"line":243,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"readdirRecursive","description":"Reads files recursively from a directory.","scope":"static","params":[{"name":"directory","description":"Directory to read.","type":[[["string"]]]}],"returns":[[["Array","<"],["string",">"]]],"meta":{"line":254,"file":"AkairoHandler.js","path":"src/struct"}}],"events":[{"name":"load","description":"Emitted when a module is loaded.","params":[{"name":"mod","description":"Module loaded.","type":[[["AkairoModule"]]]}],"meta":{"line":277,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"add","description":"Emitted when a module is added.","params":[{"name":"mod","description":"Module added.","type":[[["AkairoModule"]]]}],"meta":{"line":283,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"remove","description":"Emitted when a module is removed.","params":[{"name":"mod","description":"Module removed.","type":[[["AkairoModule"]]]}],"meta":{"line":289,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reload","description":"Emitted when a module is reloaded.","params":[{"name":"mod","description":"Module reloaded.","type":[[["AkairoModule"]]]}],"meta":{"line":295,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"enable","description":"Emitted when a module is enabled.","params":[{"name":"mod","description":"Module enabled.","type":[[["AkairoModule"]]]}],"meta":{"line":301,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"disable","description":"Emitted when a module is disabled.","params":[{"name":"mod","description":"Module disabled.","type":[[["AkairoModule"]]]}],"meta":{"line":307,"file":"AkairoHandler.js","path":"src/struct"}}],"meta":{"line":19,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"AkairoModule","description":"Base class for a module.","construct":{"name":"AkairoModule","params":[{"name":"id","description":"ID of module.","type":[[["string"]]]},{"name":"exec","description":"Function called when module is used.","type":[[["ModuleExecFunction"]]]},{"name":"options","description":"Options.","optional":true,"default":"{}","type":[[["ModuleOptions"]]]}]},"props":[{"name":"id","description":"ID of the module.","type":[[["string"]]],"meta":{"line":20,"file":"AkairoModule.js","path":"src/struct"}},{"name":"category","description":"Category this belongs to.","type":[[["Category"]]],"meta":{"line":26,"file":"AkairoModule.js","path":"src/struct"}},{"name":"enabled","description":"Whether or not this is enabled.","type":[[["boolean"]]],"meta":{"line":32,"file":"AkairoModule.js","path":"src/struct"}},{"name":"filepath","description":"The filepath.","readonly":true,"type":[[["string"]]],"meta":{"line":39,"file":"AkairoModule.js","path":"src/struct"}},{"name":"client","description":"The Akairo client.","readonly":true,"type":[[["AkairoClient"]]],"meta":{"line":46,"file":"AkairoModule.js","path":"src/struct"}},{"name":"handler","description":"The handler.","readonly":true,"type":[[["AkairoHandler"]]],"meta":{"line":53,"file":"AkairoModule.js","path":"src/struct"}}],"methods":[{"name":"exec","description":"Executes the module.","params":[{"name":"args","description":"Arguments.","variable":true,"type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":61,"file":"AkairoModule.js","path":"src/struct"}},{"name":"reload","description":"Reloads the module.","returns":[[["AkairoModule"]]],"meta":{"line":68,"file":"AkairoModule.js","path":"src/struct"}},{"name":"remove","description":"Removes the module.","returns":[[["AkairoModule"]]],"meta":{"line":76,"file":"AkairoModule.js","path":"src/struct"}},{"name":"enable","description":"Enables the module.","returns":[[["boolean"]]],"meta":{"line":84,"file":"AkairoModule.js","path":"src/struct"}},{"name":"disable","description":"Disables the module.","returns":[[["boolean"]]],"meta":{"line":95,"file":"AkairoModule.js","path":"src/struct"}},{"name":"toString","description":"Returns the ID.","returns":[[["string"]]],"meta":{"line":106,"file":"AkairoModule.js","path":"src/struct"}}],"meta":{"line":9,"file":"AkairoModule.js","path":"src/struct"}},{"name":"Argument","description":"Represents an argument for a command.","construct":{"name":"Argument","params":[{"name":"command","description":"Command of the argument.","type":[[["Command"]]]},{"name":"options","description":"Options for the argument.","type":[[["ArgumentOptions"]]]}]},"props":[{"name":"id","description":"The ID of the argument.","type":[[["string"]]],"meta":{"line":14,"file":"Argument.js","path":"src/struct"}},{"name":"command","description":"The command this argument belongs to.","type":[[["Command"]]],"meta":{"line":20,"file":"Argument.js","path":"src/struct"}},{"name":"match","description":"The method to match text.","type":[[["ArgumentMatch"]]],"meta":{"line":26,"file":"Argument.js","path":"src/struct"}},{"name":"type","description":"The type to cast to.","type":[[["ArgumentType"]]],"meta":{"line":32,"file":"Argument.js","path":"src/struct"}},{"name":"prefix","description":"The prefix to use for flag or prefix args.","type":[[["string"]],[["Array","<"],["string",">"]]],"meta":{"line":38,"file":"Argument.js","path":"src/struct"}},{"name":"index","description":"The index to skip to.","nullable":true,"type":[[["number"]]],"meta":{"line":44,"file":"Argument.js","path":"src/struct"}},{"name":"description","description":"The description.","type":[[["string"]]],"meta":{"line":50,"file":"Argument.js","path":"src/struct"}},{"name":"prompt","description":"The prompt options.","nullable":true,"type":[[["ArgumentPromptOptions"]]],"meta":{"line":56,"file":"Argument.js","path":"src/struct"}},{"name":"client","description":"The client.","readonly":true,"type":[[["AkairoClient"]]],"meta":{"line":74,"file":"Argument.js","path":"src/struct"}},{"name":"handler","description":"The command handler.","readonly":true,"type":[[["CommandHandler"]]],"meta":{"line":83,"file":"Argument.js","path":"src/struct"}}],"methods":[{"name":"default","description":"The default value.","params":[{"name":"message","description":"The message that called the command.","type":[[["Message"]]]},{"name":"args","description":"Previous arguments from command.","type":[[["Object"]]]}],"returns":[[["any"]]],"meta":{"line":58,"file":"Argument.js","path":"src/struct"}},{"name":"cast","description":"Casts the type of this argument onto a word.","params":[{"name":"word","description":"The word to cast.","type":[[["string"]]]},{"name":"message","description":"The message that called the command.","type":[[["Message"]]]},{"name":"args","description":"Previous arguments from command.","type":[[["Object"]]]}],"returns":[[["Promise","<"],["any",">"]]],"meta":{"line":94,"file":"Argument.js","path":"src/struct"}},{"name":"_processType","description":"Processes the type casting.","access":"private","params":[{"name":"word","description":"Word to process.","type":[[["string"]]]},{"name":"message","description":"Message that called the command.","type":[[["Message"]]]},{"name":"args","description":"Previous arguments from command.","type":[[["Object"]]]}],"returns":[[["any"]]],"meta":{"line":122,"file":"Argument.js","path":"src/struct"}},{"name":"_promptArgument","description":"Prompts a message for a word and casts it.","access":"private","params":[{"name":"message","description":"Message to prompt.","type":[[["Message"]]]},{"name":"args","description":"Previous arguments from command.","type":[[["Object"]]]}],"returns":[[["Promise","<"],["any",">"]]],"meta":{"line":176,"file":"Argument.js","path":"src/struct"}}],"meta":{"line":8,"file":"Argument.js","path":"src/struct"}},{"name":"ClientUtil","description":"Client utilities to help with common tasks.","construct":{"name":"ClientUtil","params":[{"name":"client","description":"The client.","type":[[["AkairoClient"]]]}]},"props":[{"name":"client","description":"The Akairo client.","readonly":true,"type":[[["AkairoClient"]]],"meta":{"line":9,"file":"ClientUtil.js","path":"src/struct"}}],"methods":[{"name":"resolveUser","description":"Resolves a user from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"users","description":"Collection of users to find in.","type":[[["Collection"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["User"]]],"meta":{"line":28,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveUsers","description":"Resolves multiple users from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"users","description":"Collection of users to find in.","type":[[["Collection"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Collection","<"],["string",", "],["User",">"]]],"meta":{"line":40,"file":"ClientUtil.js","path":"src/struct"}},{"name":"checkUser","description":"Checks if a string could be referring to a user.","params":[{"name":"text","description":"Text to check.","type":[[["string"]]]},{"name":"user","description":"User to check.","type":[[["User"]]]},{"name":"caseSensitive","description":"Makes checking by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes checking by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["boolean"]]],"meta":{"line":52,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveMember","description":"Resolves a member from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"members","description":"Collection of members to find in.","type":[[["Collection"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["GuildMember"]]],"meta":{"line":81,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveMembers","description":"Resolves multiple members from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"members","description":"Collection of members to find in.","type":[[["Collection"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Collection","<"],["string",", "],["GuildMember",">"]]],"meta":{"line":93,"file":"ClientUtil.js","path":"src/struct"}},{"name":"checkMember","description":"Checks if a string could be referring to a member.","params":[{"name":"text","description":"Text to check.","type":[[["string"]]]},{"name":"member","description":"Member to check.","type":[[["GuildMember"]]]},{"name":"caseSensitive","description":"Makes checking by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes checking by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["boolean"]]],"meta":{"line":105,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveChannel","description":"Resolves a guild channel from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"channels","description":"Collection of channels to find in.","type":[[["Collection"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["GuildChannel"]]],"meta":{"line":137,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveChannels","description":"Resolves multiple guild channels from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"channels","description":"Collection of channels to find in.","type":[[["Collection"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Collection","<"],["string",", "],["GuildChannel",">"]]],"meta":{"line":149,"file":"ClientUtil.js","path":"src/struct"}},{"name":"checkChannel","description":"Checks if a string could be referring to a channel.","params":[{"name":"text","description":"Text to check.","type":[[["string"]]]},{"name":"channel","description":"Channel to check.","type":[[["Channel"]]]},{"name":"caseSensitive","description":"Makes checking by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes checking by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["boolean"]]],"meta":{"line":161,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveRole","description":"Resolves a role from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"roles","description":"Collection of roles to find in.","type":[[["Collection"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Role"]]],"meta":{"line":189,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveRoles","description":"Resolves multiple roles from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"roles","description":"Collection of roles to find in.","type":[[["Collection"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Collection","<"],["string",", "],["Role",">"]]],"meta":{"line":201,"file":"ClientUtil.js","path":"src/struct"}},{"name":"checkRole","description":"Checks if a string could be referring to a role.","params":[{"name":"text","description":"Text to check.","type":[[["string"]]]},{"name":"role","description":"Role to check.","type":[[["Role"]]]},{"name":"caseSensitive","description":"Makes checking by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes checking by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["boolean"]]],"meta":{"line":213,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveEmoji","description":"Resolves a custom emoji from a string, such as a name or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"emojis","description":"Collection of emojis to find in.","type":[[["Collection"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Emoji"]]],"meta":{"line":241,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveEmojis","description":"Resolves multiple custom emojis from a string, such as a name or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"emojis","description":"Collection of emojis to find in.","type":[[["Collection"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Collection","<"],["string",", "],["Emoji",">"]]],"meta":{"line":253,"file":"ClientUtil.js","path":"src/struct"}},{"name":"checkEmoji","description":"Checks if a string could be referring to a emoji.","params":[{"name":"text","description":"Text to check.","type":[[["string"]]]},{"name":"emoji","description":"Emoji to check.","type":[[["Emoji"]]]},{"name":"caseSensitive","description":"Makes checking by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes checking by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["boolean"]]],"meta":{"line":265,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveGuild","description":"Resolves a guild from a string, such as an ID or a name.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"guilds","description":"Collection of guilds to find in.","type":[[["Collection"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Guild"]]],"meta":{"line":293,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveGuilds","description":"Resolves multiple guilds from a string, such as an ID or a name.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"guilds","description":"Collection of guilds to find in.","type":[[["Collection"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Collection","<"],["string",", "],["Guild",">"]]],"meta":{"line":305,"file":"ClientUtil.js","path":"src/struct"}},{"name":"checkGuild","description":"Checks if a string could be referring to a guild.","params":[{"name":"text","description":"Text to check.","type":[[["string"]]]},{"name":"guild","description":"Guild to check.","type":[[["Guild"]]]},{"name":"caseSensitive","description":"Makes checking by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes checking by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["boolean"]]],"meta":{"line":317,"file":"ClientUtil.js","path":"src/struct"}},{"name":"displayRole","description":"Gets the role which is used to display the member's color.","deprecated":"Use GuildMember#colorRole","params":[{"name":"member","description":"The member to find the role.","type":[[["GuildMember"]]]}],"returns":[[["Role"]]],"meta":{"line":333,"file":"ClientUtil.js","path":"src/struct"}},{"name":"displayColor","description":"Gets the display color in decimal of the member.","deprecated":"Use GuildMember#displayColor","params":[{"name":"member","description":"The member to find color of.","type":[[["GuildMember"]]]}],"returns":[[["number"]]],"meta":{"line":345,"file":"ClientUtil.js","path":"src/struct"}},{"name":"displayHexColor","description":"Gets the display color in hex code of the member.","deprecated":"Use GuildMember#displayHexColor","params":[{"name":"member","description":"The member to find color of.","type":[[["GuildMember"]]]}],"returns":[[["string"]]],"meta":{"line":356,"file":"ClientUtil.js","path":"src/struct"}},{"name":"hoistRole","description":"Gets the role which is used to hoist the member.","deprecated":"Use GuildMember#hoistRole","params":[{"name":"member","description":"The member to find the role.","type":[[["GuildMember"]]]}],"returns":[[["Role"]]],"meta":{"line":367,"file":"ClientUtil.js","path":"src/struct"}},{"name":"permissionNames","description":"Array of permission names.","returns":[[["Array","<"],["string",">"]]],"meta":{"line":377,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolvePermissionNumber","description":"Resolves a permission number and returns an array of permission names.","params":[{"name":"number","description":"The permissions number.","type":[[["number"]]]}],"returns":[[["Array","<"],["string",">"]]],"meta":{"line":386,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolvePermissionOverwrite","description":"Resolves a channel permission overwrite.\nReturns an object with the `allow` and `deny` arrays of permission names.","deprecated":"Use Permissions constructor","params":[{"name":"overwrite","description":"Permissions overwrite.","type":[[["PermissionOverwrites"]]]}],"returns":[[["Object"]]],"meta":{"line":403,"file":"ClientUtil.js","path":"src/struct"}},{"name":"compareStreaming","description":"Compares two member objects presences and checks if they stopped or started a stream or not.\nReturns `0`, `1`, or `2` for no change, stopped, or started.","params":[{"name":"oldMember","description":"The old member.","type":[[["GuildMember"]]]},{"name":"newMember","description":"The new member.","type":[[["GuildMember"]]]}],"returns":[[["number"]]],"meta":{"line":417,"file":"ClientUtil.js","path":"src/struct"}},{"name":"fetchMemberFrom","description":"Combination of `<Client>.fetchUser()` and `<Guild>.fetchMember()`.","params":[{"name":"guild","description":"Guild to fetch in.","type":[[["Guild"]]]},{"name":"id","description":"ID of the user.","type":[[["string"]]]},{"name":"cache","description":"Whether or not to add to cache.","type":[[["boolean"]]]}],"returns":[[["Promise","<"],["GuildMember",">"]]],"meta":{"line":434,"file":"ClientUtil.js","path":"src/struct"}},{"name":"embed","description":"Makes a RichEmbed.","params":[{"name":"data","description":"Embed data.","optional":true,"type":[[["Object"]]]}],"returns":[[["RichEmbed"]]],"meta":{"line":445,"file":"ClientUtil.js","path":"src/struct"}},{"name":"collection","description":"Makes a Collection.","params":[{"name":"iterable","description":"Entries to fill with.","optional":true,"type":[[["Iterable"]]]}],"returns":[[["Collection"]]],"meta":{"line":454,"file":"ClientUtil.js","path":"src/struct"}},{"name":"prompt","description":"Prompts a user for input, returning the message that passes.","deprecated":"Use message collectors","params":[{"name":"message","description":"Message to prompt.","type":[[["Message"]]]},{"name":"content","description":"Text to send.","optional":true,"type":[[["string"]]]},{"name":"check","description":"Regex or function to check if message should pass.","optional":true,"type":[[["RegExp"]],[["PromptCheckFunction"]]]},{"name":"time","description":"Time in milliseconds to wait.","optional":true,"default":30000,"type":[[["number"]]]},{"name":"options","description":"Message options for message.","optional":true,"type":[[["MessageOptions"]]]}],"returns":[[["Promise","<"],["Message",">"]]],"meta":{"line":468,"file":"ClientUtil.js","path":"src/struct"}},{"name":"promptIn","description":"Prompts a user for input in a specific channel, returning the message that passes.","deprecated":"Use message collectors","params":[{"name":"channel","description":"Channel to prompt in or a user to prompt in DM.","type":[[["TextBasedChannel"]],[["User"]]]},{"name":"user","description":"User to prompt, if not a user object in the channel param.","optional":true,"type":[[["User"]]]},{"name":"content","description":"Text to send.","optional":true,"type":[[["string"]]]},{"name":"check","description":"Regex or function to check if message should pass.","optional":true,"type":[[["RegExp"]],[["PromptCheckFunction"]]]},{"name":"time","description":"Time in milliseconds to wait.","optional":true,"default":30000,"type":[[["number"]]]},{"name":"options","description":"Message options for message.","optional":true,"type":[[["MessageOptions"]]]}],"returns":[[["Promise","<"],["Message",">"]]],"meta":{"line":515,"file":"ClientUtil.js","path":"src/struct"}},{"name":"fetchMessage","description":"Fetches a message, works for both bots and user accounts.","deprecated":"Use TextBasedChannel#fetchMessage","params":[{"name":"channel","description":"Channel to fetch in.","type":[[["TextBasedChannel"]]]},{"name":"id","description":"ID of the message.","type":[[["Snowflake"]]]}],"returns":[[["Promise","<"],["Message",">"]]],"meta":{"line":547,"file":"ClientUtil.js","path":"src/struct"}}],"meta":{"line":7,"file":"ClientUtil.js","path":"src/struct"}},{"name":"Command","description":"Represents a command.","extends":["AkairoModule"],"construct":{"name":"Command","params":[{"name":"id","description":"Command ID.","type":[[["string"]]]},{"name":"exec","description":"Function called when command is ran.","type":[[["CommandExecFunction"]],[["RegexCommandExecFunction"]],[["ConditionalCommandExecFunction"]]]},{"name":"options","description":"Options for the command.","optional":true,"default":"{}","type":[[["CommandOptions"]]]}]},"props":[{"name":"aliases","description":"Command names.","type":[[["Array","<"],["string",">"]]],"meta":{"line":25,"file":"Command.js","path":"src/struct"}},{"name":"args","description":"Arguments for the command.","type":[[["Array","<"],["Argument",">"]]],"meta":{"line":31,"file":"Command.js","path":"src/struct"}},{"name":"split","description":"The command split method.","type":[[["ArgumentSplit"]]],"meta":{"line":37,"file":"Command.js","path":"src/struct"}},{"name":"channelRestriction","description":"Usable only in this channel type.","nullable":true,"type":[[["string"]]],"meta":{"line":43,"file":"Command.js","path":"src/struct"}},{"name":"ownerOnly","description":"Usable only by the client owner.","type":[[["boolean"]]],"meta":{"line":49,"file":"Command.js","path":"src/struct"}},{"name":"protected","description":"Whether or not this command cannot be disabled.","type":[[["boolean"]]],"meta":{"line":55,"file":"Command.js","path":"src/struct"}},{"name":"editable","description":"Whether or not this command can be ran by an edit.","type":[[["boolean"]]],"meta":{"line":61,"file":"Command.js","path":"src/struct"}},{"name":"typing","description":"Whether or not to type during command execution.","type":[[["boolean"]]],"meta":{"line":67,"file":"Command.js","path":"src/struct"}},{"name":"cooldown","description":"Cooldown in milliseconds.","nullable":true,"type":[[["number"]]],"meta":{"line":73,"file":"Command.js","path":"src/struct"}},{"name":"ratelimit","description":"Uses allowed before cooldown.","type":[[["number"]]],"meta":{"line":79,"file":"Command.js","path":"src/struct"}},{"name":"defaultPrompt","description":"Default prompt options.","type":[[["ArgumentPromptOptions"]]],"meta":{"line":85,"file":"Command.js","path":"src/struct"}},{"name":"options","description":"Custom options for the command.","deprecated":"Extend the class.","type":[[["Object"]]],"meta":{"line":92,"file":"Command.js","path":"src/struct"}},{"name":"description","description":"Description of the command.","type":[[["string"]]],"meta":{"line":98,"file":"Command.js","path":"src/struct"}},{"name":"prefix","description":"Command prefix overwrite.","type":[[["string"]],[["Array","<"],["string",">"]],[["PrefixFunction"]]],"meta":{"line":104,"file":"Command.js","path":"src/struct"}},{"name":"clientPermissions","description":"Permissions required to run command by the client.","type":[[["PermissionResolvable"]],[["Array","<"],["PermissionResolvable",">"]],[["PermissionFunction"]]],"meta":{"line":110,"file":"Command.js","path":"src/struct"}},{"name":"userPermissions","description":"Permissions required to run command by the user.","type":[[["PermissionResolvable"]],[["Array","<"],["PermissionResolvable",">"]],[["PermissionFunction"]]],"meta":{"line":116,"file":"Command.js","path":"src/struct"}},{"name":"id","description":"ID of the module.","type":[[["string"]]],"meta":{"line":20,"file":"AkairoModule.js","path":"src/struct"}},{"name":"category","description":"Category this belongs to.","type":[[["Category"]]],"meta":{"line":26,"file":"AkairoModule.js","path":"src/struct"}},{"name":"enabled","description":"Whether or not this is enabled.","type":[[["boolean"]]],"meta":{"line":32,"file":"AkairoModule.js","path":"src/struct"}},{"name":"filepath","description":"The filepath.","readonly":true,"type":[[["string"]]],"meta":{"line":39,"file":"AkairoModule.js","path":"src/struct"}},{"name":"client","description":"The Akairo client.","readonly":true,"type":[[["AkairoClient"]]],"meta":{"line":46,"file":"AkairoModule.js","path":"src/struct"}},{"name":"handler","description":"The handler.","readonly":true,"type":[[["AkairoHandler"]]],"meta":{"line":53,"file":"AkairoModule.js","path":"src/struct"}}],"methods":[{"name":"trigger","description":"Gets the regex trigger, if specified.","params":[{"name":"message","description":"Message being handled.","type":[[["Message"]]]}],"returns":[[["RegExp"]]],"meta":{"line":124,"file":"Command.js","path":"src/struct"}},{"name":"condition","description":"Gets the condition trigger, if specified.","params":[{"name":"message","description":"Message being handled.","type":[[["Message"]]]}],"returns":[[["boolean"]]],"meta":{"line":132,"file":"Command.js","path":"src/struct"}},{"name":"parse","description":"Parses text based on this command's args.","params":[{"name":"content","description":"String to parse.","type":[[["string"]]]},{"name":"message","description":"Message to use.","optional":true,"type":[[["Message"]]]}],"returns":[[["Promise","<"],["Object",">"]]],"meta":{"line":164,"file":"Command.js","path":"src/struct"}},{"name":"disable","description":"Disables the command.","returns":[[["boolean"]]],"meta":{"line":324,"file":"Command.js","path":"src/struct"}},{"name":"exec","description":"Executes the module.","inherits":"AkairoModule#exec","inherited":true,"params":[{"name":"args","description":"Arguments.","variable":true,"type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":61,"file":"AkairoModule.js","path":"src/struct"}},{"name":"reload","description":"Reloads the module.","inherits":"AkairoModule#reload","inherited":true,"returns":[[["AkairoModule"]]],"meta":{"line":68,"file":"AkairoModule.js","path":"src/struct"}},{"name":"remove","description":"Removes the module.","inherits":"AkairoModule#remove","inherited":true,"returns":[[["AkairoModule"]]],"meta":{"line":76,"file":"AkairoModule.js","path":"src/struct"}},{"name":"enable","description":"Enables the module.","inherits":"AkairoModule#enable","inherited":true,"returns":[[["boolean"]]],"meta":{"line":84,"file":"AkairoModule.js","path":"src/struct"}},{"name":"toString","description":"Returns the ID.","inherits":"AkairoModule#toString","inherited":true,"returns":[[["string"]]],"meta":{"line":106,"file":"AkairoModule.js","path":"src/struct"}}],"meta":{"line":12,"file":"Command.js","path":"src/struct"}},{"name":"CommandHandler","description":"Loads commands and handles messages.","extends":["AkairoHandler"],"construct":{"name":"CommandHandler","params":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]]},{"name":"options","description":"Options from client.","type":[[["Object"]]]}]},"props":[{"name":"resolver","description":"The type resolver.","type":[[["TypeResolver"]]],"meta":{"line":22,"file":"CommandHandler.js","path":"src/struct"}},{"name":"aliases","description":"Collecion of command aliases.","type":[[["Collection","<"],["string",", "],["string",">"]]],"meta":{"line":28,"file":"CommandHandler.js","path":"src/struct"}},{"name":"prefixes","description":"Set of prefix overwrites.","type":[[["Set","<("],["string","|"],["Array","<"],["string",">|"],["PrefixFunction",")>"]]],"meta":{"line":34,"file":"CommandHandler.js","path":"src/struct"}},{"name":"blockNotSelf","description":"Whether or not to block others, if a selfbot.","type":[[["boolean"]]],"meta":{"line":40,"file":"CommandHandler.js","path":"src/struct"}},{"name":"blockClient","description":"Whether or not to block self, if not a selfbot.","type":[[["boolean"]]],"meta":{"line":46,"file":"CommandHandler.js","path":"src/struct"}},{"name":"blockBots","description":"Whether or not to block bots.","type":[[["boolean"]]],"meta":{"line":52,"file":"CommandHandler.js","path":"src/struct"}},{"name":"fetchMembers","description":"Whether or not `fetchMember()` is used on each message author from a guild.","type":[[["boolean"]]],"meta":{"line":58,"file":"CommandHandler.js","path":"src/struct"}},{"name":"handleEdits","description":"Whether or not edits are handled.","type":[[["boolean"]]],"meta":{"line":64,"file":"CommandHandler.js","path":"src/struct"}},{"name":"commandUtil","description":"Whether or not `message.util` is assigned.","type":[[["boolean"]]],"meta":{"line":70,"file":"CommandHandler.js","path":"src/struct"}},{"name":"commandUtilLifetime","description":"How long a command util will last in milliseconds before it is removed.","type":[[["number"]]],"meta":{"line":76,"file":"CommandHandler.js","path":"src/struct"}},{"name":"commandUtils","description":"Collection of CommandUtils.","type":[[["Collection","<"],["string",", "],["CommandUtil",">"]]],"meta":{"line":82,"file":"CommandHandler.js","path":"src/struct"}},{"name":"cooldowns","description":"Collection of cooldowns.","type":[[["Collection","<"],["string",", "],["Object",">"]]],"meta":{"line":88,"file":"CommandHandler.js","path":"src/struct"}},{"name":"defaultCooldown","description":"Default cooldown for commands.","type":[[["number"]]],"meta":{"line":94,"file":"CommandHandler.js","path":"src/struct"}},{"name":"prompts","description":"Collection of sets of ongoing argument prompts.","type":[[["Collection","<"],["string",", "],["Set",">"]]],"meta":{"line":100,"file":"CommandHandler.js","path":"src/struct"}},{"name":"defaultPrompt","description":"Default prompt options.","type":[[["ArgumentPromptOptions"]]],"meta":{"line":106,"file":"CommandHandler.js","path":"src/struct"}},{"name":"client","description":"The Akairo client.","readonly":true,"type":[[["AkairoClient"]]],"meta":{"line":23,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"directory","description":"Directory to modules.","readonly":true,"type":[[["string"]]],"meta":{"line":30,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"classToHandle","description":"Class to handle.","readonly":true,"type":[[["function"]]],"meta":{"line":37,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"modules","description":"Modules loaded, mapped by ID to AkairoModule.","type":[[["Collection","<"],["string",", "],["AkairoModule",">"]]],"meta":{"line":60,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"categories","description":"Categories, mapped by ID to Category.","type":[[["Collection","<"],["string",", "],["Category",">"]]],"meta":{"line":66,"file":"AkairoHandler.js","path":"src/struct"}}],"methods":[{"name":"prefix","description":"Gets the prefix.","params":[{"name":"message","description":"Message being handled.","type":[[["Message"]]]}],"returns":[[["string"]]],"meta":{"line":130,"file":"CommandHandler.js","path":"src/struct"}},{"name":"allowMention","description":"Gets if mentions are allowed for prefixing.","params":[{"name":"message","description":"Message being handled.","type":[[["Message"]]]}],"returns":[[["boolean"]]],"meta":{"line":138,"file":"CommandHandler.js","path":"src/struct"}},{"name":"_apply","description":"Registers a module.","access":"private","params":[{"name":"command","description":"Module to use.","type":[[["Command"]]]},{"name":"filepath","description":"Filepath of module.","optional":true,"type":[[["string"]]]}],"returns":[[["void"]]],"meta":{"line":161,"file":"CommandHandler.js","path":"src/struct"}},{"name":"_unapply","description":"Deregisters a module.","access":"private","params":[{"name":"command","description":"Module to use.","type":[[["Command"]]]}],"returns":[[["void"]]],"meta":{"line":172,"file":"CommandHandler.js","path":"src/struct"}},{"name":"_addAliases","description":"Adds aliases of a command.","access":"private","params":[{"name":"command","description":"Command to use.","type":[[["Command"]]]}],"returns":[[["void"]]],"meta":{"line":183,"file":"CommandHandler.js","path":"src/struct"}},{"name":"_removeAliases","description":"Removes aliases of a command.","access":"private","params":[{"name":"command","description":"Command to use.","type":[[["Command"]]]}],"returns":[[["void"]]],"meta":{"line":202,"file":"CommandHandler.js","path":"src/struct"}},{"name":"findCommand","description":"Finds a command by alias.","params":[{"name":"name","description":"Alias to find with.","type":[[["string"]]]}],"returns":[[["Command"]]],"meta":{"line":217,"file":"CommandHandler.js","path":"src/struct"}},{"name":"addPrompt","description":"Adds an ongoing prompt in order to prevent command usage in the channel.","params":[{"name":"message","description":"Message to use.","type":[[["Message"]]]}],"returns":[[["void"]]],"meta":{"line":226,"file":"CommandHandler.js","path":"src/struct"}},{"name":"removePrompt","description":"Removes an ongoing prompt.","params":[{"name":"message","description":"Message to use.","type":[[["Message"]]]}],"returns":[[["void"]]],"meta":{"line":239,"file":"CommandHandler.js","path":"src/struct"}},{"name":"hasPrompt","description":"Checks if there is an ongoing prompt.","params":[{"name":"message","description":"Message to use.","type":[[["Message"]]]}],"returns":[[["boolean"]]],"meta":{"line":252,"file":"CommandHandler.js","path":"src/struct"}},{"name":"handle","description":"Handles a message.","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]},{"name":"edited","description":"Whether or not the message was edited.","type":[[["boolean"]]]}],"returns":[[["Promise","<"],["void",">"]]],"meta":{"line":264,"file":"CommandHandler.js","path":"src/struct"}},{"name":"_runInhibitors","description":"Runs built in command inhibitors.","access":"private","params":[{"name":"message","description":"Message that called the command.","type":[[["Message"]]]},{"name":"command","description":"Command to check.","type":[[["Command"]]]}],"returns":[[["boolean"]]],"meta":{"line":381,"file":"CommandHandler.js","path":"src/struct"}},{"name":"_parseCommand","description":"Parses the command and its argument list.","access":"private","params":[{"name":"message","description":"Message that called the command.","type":[[["Message"]]]}],"returns":[[["Object"]]],"meta":{"line":436,"file":"CommandHandler.js","path":"src/struct"}},{"name":"_handleCooldowns","description":"Handles cooldowns and checks if a user is under cooldown.","access":"private","params":[{"name":"message","description":"Message that called the command.","type":[[["Message"]]]},{"name":"command","description":"Command to cooldown.","type":[[["Command"]]]}],"returns":[[["boolean"]]],"meta":{"line":524,"file":"CommandHandler.js","path":"src/struct"}},{"name":"_handleTriggers","description":"Handles regex and conditional commands.","access":"private","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]},{"name":"edited","description":"Whether or not the message was edited.","type":[[["boolean"]]]}],"returns":[[["Promise","<"],["void",">"]]],"meta":{"line":569,"file":"CommandHandler.js","path":"src/struct"}},{"name":"_handleRegex","description":"Handles regex commands.","access":"private","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]},{"name":"edited","description":"Whether or not the message was edited.","type":[[["boolean"]]]}],"returns":[[["Promise","<"],["void",">"]]],"meta":{"line":582,"file":"CommandHandler.js","path":"src/struct"}},{"name":"_handleConditional","description":"Handles conditional commands.","access":"private","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]},{"name":"edited","description":"Whether or not the message was edited.","type":[[["boolean"]]]}],"returns":[[["Promise","<"],["void",">"]]],"meta":{"line":654,"file":"CommandHandler.js","path":"src/struct"}},{"name":"_handleError","description":"Handles errors from the handling.","access":"private","params":[{"name":"err","description":"The error.","type":[[["Error"]]]},{"name":"message","description":"Message that called the command.","type":[[["Message"]]]},{"name":"command","description":"Command that errored.","optional":true,"type":[[["Command"]]]}],"returns":[[["void"]]],"meta":{"line":706,"file":"CommandHandler.js","path":"src/struct"}},{"name":"loadAll","description":"Reads all modules from the directory and loads them.","inherits":"AkairoHandler#loadAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":73,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"load","description":"Loads a module, can be a filepath or an object.","inherits":"AkairoHandler#load","inherited":true,"params":[{"name":"thing","description":"Module or path to module.","type":[[["string"]],[["AkairoModule"]]]},{"name":"isReload","description":"Whether this is a reload or not.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":130,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"add","description":"Adds a module.","inherits":"AkairoHandler#add","inherited":true,"deprecated":"Use AkairoHandler#load","params":[{"name":"filename","description":"Filename to lookup in the directory.\nA .js extension is assumed.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":169,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"remove","description":"Removes a module.","inherits":"AkairoHandler#remove","inherited":true,"params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":185,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"removeAll","description":"Removes all modules.","inherits":"AkairoHandler#removeAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":199,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reload","description":"Reloads a module.","inherits":"AkairoHandler#reload","inherited":true,"params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":212,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reloadAll","description":"Reloads all modules.","inherits":"AkairoHandler#reloadAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":230,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"findCategory","description":"Finds a category by name.","inherits":"AkairoHandler#findCategory","inherited":true,"params":[{"name":"name","description":"Name to find with.","type":[[["string"]]]}],"returns":[[["Category"]]],"meta":{"line":243,"file":"AkairoHandler.js","path":"src/struct"}}],"events":[{"name":"messageBlocked","description":"Emitted when a message is blocked by a pre-message inhibitor.\nThe built-in inhibitors are 'notSelf' (for selfbots), 'client', and 'bot'.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"reason","description":"Reason for the block.","type":[[["string"]]]}],"meta":{"line":772,"file":"CommandHandler.js","path":"src/struct"}},{"name":"messageInvalid","description":"Emitted when a message does not start with the prefix or match a command.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]}],"meta":{"line":780,"file":"CommandHandler.js","path":"src/struct"}},{"name":"commandDisabled","description":"Emitted when a command is found disabled.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command found.","type":[[["Command"]]]}],"meta":{"line":786,"file":"CommandHandler.js","path":"src/struct"}},{"name":"commandBlocked","description":"Emitted when a command is blocked by a post-message inhibitor.\nThe built-in inhibitors are 'owner', 'guild', 'dm', 'clientPermissions', and 'userPermissions'.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command blocked.","type":[[["Command"]]]},{"name":"reason","description":"Reason for the block.","type":[[["string"]]]}],"meta":{"line":793,"file":"CommandHandler.js","path":"src/struct"}},{"name":"commandCooldown","description":"Emitted when a command is found on cooldown.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command blocked.","type":[[["Command"]]]},{"name":"remaining","description":"Remaining time in milliseconds for cooldown.","type":[[["number"]]]}],"meta":{"line":802,"file":"CommandHandler.js","path":"src/struct"}},{"name":"commandStarted","description":"Emitted when a command starts execution.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command executed.","type":[[["Command"]]]},{"name":"edited","description":"Whether or not the command came from an edited message.","type":[[["boolean"]]]}],"meta":{"line":810,"file":"CommandHandler.js","path":"src/struct"}},{"name":"commandFinished","description":"Emitted when a command finishes execution.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command executed.","type":[[["Command"]]]},{"name":"edited","description":"Whether or not the command came from an edited message.","type":[[["boolean"]]]}],"meta":{"line":818,"file":"CommandHandler.js","path":"src/struct"}},{"name":"inPrompt","description":"Emitted when a user is in a command argument prompt.\nUsed to prevent usage of commands during a prompt.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]}],"meta":{"line":826,"file":"CommandHandler.js","path":"src/struct"}},{"name":"error","description":"Emitted when a command or inhibitor errors.","params":[{"name":"error","description":"The error.","type":[[["Error"]]]},{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command executed.","nullable":true,"type":[[["Command"]]]}],"meta":{"line":833,"file":"CommandHandler.js","path":"src/struct"}},{"name":"load","description":"Emitted when a command is loaded.","params":[{"name":"command","description":"Module loaded.","type":[[["Command"]]]}],"meta":{"line":841,"file":"CommandHandler.js","path":"src/struct"}},{"name":"add","description":"Emitted when a command is added.","params":[{"name":"command","description":"Command added.","type":[[["Command"]]]}],"meta":{"line":847,"file":"CommandHandler.js","path":"src/struct"}},{"name":"remove","description":"Emitted when a command is removed.","params":[{"name":"command","description":"Command removed.","type":[[["Command"]]]}],"meta":{"line":853,"file":"CommandHandler.js","path":"src/struct"}},{"name":"reload","description":"Emitted when a command is reloaded.","params":[{"name":"command","description":"Command reloaded.","type":[[["Command"]]]}],"meta":{"line":859,"file":"CommandHandler.js","path":"src/struct"}},{"name":"enable","description":"Emitted when a command is enabled.","params":[{"name":"command","description":"Command enabled.","type":[[["Command"]]]}],"meta":{"line":865,"file":"CommandHandler.js","path":"src/struct"}},{"name":"disable","description":"Emitted when a command is disabled.","params":[{"name":"command","description":"Command disabled.","type":[[["Command"]]]}],"meta":{"line":871,"file":"CommandHandler.js","path":"src/struct"}}],"meta":{"line":14,"file":"CommandHandler.js","path":"src/struct"}},{"name":"CommandUtil","description":"Command utilies.","construct":{"name":"CommandUtil","params":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]]},{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"command","description":"Command triggered.","type":[[["Command"]]]},{"name":"prefix","description":"Prefix used to trigger.","optional":true,"type":[[["string"]]]},{"name":"alias","description":"Alias used to trigger.","optional":true,"type":[[["string"]]]}]},"props":[{"name":"client","description":"The Akairo client.","readonly":true,"type":[[["AkairoClient"]]],"meta":{"line":11,"file":"CommandUtil.js","path":"src/struct"}},{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]],"meta":{"line":27,"file":"CommandUtil.js","path":"src/struct"}},{"name":"command","description":"Command used.","type":[[["Command"]]],"meta":{"line":33,"file":"CommandUtil.js","path":"src/struct"}},{"name":"prefix","description":"The prefix used.","nullable":true,"type":[[["string"]]],"meta":{"line":39,"file":"CommandUtil.js","path":"src/struct"}},{"name":"alias","description":"The alias used.","nullable":true,"type":[[["string"]]],"meta":{"line":45,"file":"CommandUtil.js","path":"src/struct"}},{"name":"shouldEdit","description":"Whether or not the last response should be edited.","type":[[["boolean"]]],"meta":{"line":51,"file":"CommandUtil.js","path":"src/struct"}},{"name":"lastResponse","description":"The last response sent.","nullable":true,"type":[[["Message"]]],"meta":{"line":57,"file":"CommandUtil.js","path":"src/struct"}}],"methods":[{"name":"setLastResponse","description":"Sets the last repsonse.","params":[{"name":"message","description":"Message to set.","type":[[["Message"]],[["Array","<"],["Message",">"]]]}],"returns":[[["void"]]],"meta":{"line":65,"file":"CommandUtil.js","path":"src/struct"}},{"name":"send","description":"Sends a response or edits an old response if available.","params":[{"name":"content","description":"Content to send.","type":[[["string"]],[["MessageOptions"]],[["MessageEditOptions"]]]},{"name":"options","description":"Options to use.","optional":true,"type":[[["MessageOptions"]],[["MessageEditOptions"]]]}],"returns":[[["Promise","<("],["Message","|"],["Array","<"],["Message",">)>"]]],"meta":{"line":80,"file":"CommandUtil.js","path":"src/struct"}},{"name":"sendMessage","description":"Sends a response or edits an old response if available.","deprecated":"Use CommandUtil#send","params":[{"name":"content","description":"Content to send.","type":[[["string"]],[["MessageOptions"]],[["MessageEditOptions"]]]},{"name":"options","description":"Options to use.","optional":true,"type":[[["MessageOptions"]],[["MessageEditOptions"]]]}],"returns":[[["Promise","<("],["Message","|"],["Array","<"],["Message",">)>"]]],"meta":{"line":105,"file":"CommandUtil.js","path":"src/struct"}},{"name":"sendCode","description":"Sends a response in a codeblock or edits an old response if available.","deprecated":"Use CommandUtil#send","params":[{"name":"code","description":"Language to use for syntax highlighting.","type":[[["string"]]]},{"name":"content","description":"Content to send.","type":[[["string"]],[["MessageOptions"]],[["MessageEditOptions"]]]},{"name":"options","description":"Options to use.","optional":true,"type":[[["MessageOptions"]],[["MessageEditOptions"]]]}],"returns":[[["Promise","<("],["Message","|"],["Array","<"],["Message",">)>"]]],"meta":{"line":117,"file":"CommandUtil.js","path":"src/struct"}},{"name":"sendEmbed","description":"Sends a response with an embed or edits an old response if available.","deprecated":"Use CommandUtil#send","params":[{"name":"embed","description":"Embed to send.","type":[[["RichEmbed"]],[["Object"]]]},{"name":"content","description":"Content to send.","type":[[["string"]],[["MessageOptions"]],[["MessageEditOptions"]]]},{"name":"options","description":"Options to use.","optional":true,"type":[[["MessageOptions"]],[["MessageEditOptions"]]]}],"returns":[[["Promise","<("],["Message","|"],["Array","<"],["Message",">)>"]]],"meta":{"line":131,"file":"CommandUtil.js","path":"src/struct"}},{"name":"reply","description":"Sends a response with a mention concantenated to it.","params":[{"name":"content","description":"Content to send.","type":[[["string"]],[["MessageOptions"]],[["MessageEditOptions"]]]},{"name":"options","description":"Options to use.","optional":true,"type":[[["MessageOptions"]],[["MessageEditOptions"]]]}],"returns":[[["Promise","<("],["Message","|"],["Array","<"],["Message",">)>"]]],"meta":{"line":143,"file":"CommandUtil.js","path":"src/struct"}},{"name":"edit","description":"Edits the last response.","params":[{"name":"content","description":"Content to send.","type":[[["string"]],[["MessageEditOptions"]]]},{"name":"options","description":"Options to use.","optional":true,"type":[[["MessageEditOptions"]]]}],"returns":[[["Promise","<"],["Message",">"]]],"meta":{"line":154,"file":"CommandUtil.js","path":"src/struct"}},{"name":"swapOptions","description":"Swaps and cleans up content and options.","scope":"static","params":[{"name":"content","description":"Content to send.","type":[[["string"]],[["MessageOptions"]],[["MessageEditOptions"]]]},{"name":"options","description":"Options to use.","optional":true,"type":[[["MessageOptions"]]]}],"returns":[[["Array"]]],"meta":{"line":164,"file":"CommandUtil.js","path":"src/struct"}}],"meta":{"line":9,"file":"CommandUtil.js","path":"src/struct"}},{"name":"Inhibitor","description":"Represents a inhibitor.","extends":["AkairoModule"],"construct":{"name":"Inhibitor","params":[{"name":"id","description":"Inhibitor ID.","type":[[["string"]]]},{"name":"exec","description":"Function called before a command is ran.","type":[[["InhibitorExecFunction"]]]},{"name":"options","description":"Options for the inhibitor.","optional":true,"default":"{}","type":[[["InhibitorOptions"]]]}]},"props":[{"name":"reason","description":"Reason emitted when command is inhibited.","type":[[["string"]]],"meta":{"line":23,"file":"Inhibitor.js","path":"src/struct"}},{"name":"type","description":"When the inhibitor is ran.","type":[[["string"]]],"meta":{"line":29,"file":"Inhibitor.js","path":"src/struct"}},{"name":"id","description":"ID of the module.","type":[[["string"]]],"meta":{"line":20,"file":"AkairoModule.js","path":"src/struct"}},{"name":"category","description":"Category this belongs to.","type":[[["Category"]]],"meta":{"line":26,"file":"AkairoModule.js","path":"src/struct"}},{"name":"enabled","description":"Whether or not this is enabled.","type":[[["boolean"]]],"meta":{"line":32,"file":"AkairoModule.js","path":"src/struct"}},{"name":"filepath","description":"The filepath.","readonly":true,"type":[[["string"]]],"meta":{"line":39,"file":"AkairoModule.js","path":"src/struct"}},{"name":"client","description":"The Akairo client.","readonly":true,"type":[[["AkairoClient"]]],"meta":{"line":46,"file":"AkairoModule.js","path":"src/struct"}},{"name":"handler","description":"The handler.","readonly":true,"type":[[["AkairoHandler"]]],"meta":{"line":53,"file":"AkairoModule.js","path":"src/struct"}}],"methods":[{"name":"exec","description":"Executes the module.","inherits":"AkairoModule#exec","inherited":true,"params":[{"name":"args","description":"Arguments.","variable":true,"type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":61,"file":"AkairoModule.js","path":"src/struct"}},{"name":"reload","description":"Reloads the module.","inherits":"AkairoModule#reload","inherited":true,"returns":[[["AkairoModule"]]],"meta":{"line":68,"file":"AkairoModule.js","path":"src/struct"}},{"name":"remove","description":"Removes the module.","inherits":"AkairoModule#remove","inherited":true,"returns":[[["AkairoModule"]]],"meta":{"line":76,"file":"AkairoModule.js","path":"src/struct"}},{"name":"enable","description":"Enables the module.","inherits":"AkairoModule#enable","inherited":true,"returns":[[["boolean"]]],"meta":{"line":84,"file":"AkairoModule.js","path":"src/struct"}},{"name":"disable","description":"Disables the module.","inherits":"AkairoModule#disable","inherited":true,"returns":[[["boolean"]]],"meta":{"line":95,"file":"AkairoModule.js","path":"src/struct"}},{"name":"toString","description":"Returns the ID.","inherits":"AkairoModule#toString","inherited":true,"returns":[[["string"]]],"meta":{"line":106,"file":"AkairoModule.js","path":"src/struct"}}],"meta":{"line":10,"file":"Inhibitor.js","path":"src/struct"}},{"name":"InhibitorHandler","description":"Loads inhibitors and checks messages.","extends":["AkairoHandler"],"construct":{"name":"InhibitorHandler","params":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]]},{"name":"options","description":"Options from client.","type":[[["Object"]]]}]},"props":[{"name":"client","description":"The Akairo client.","readonly":true,"type":[[["AkairoClient"]]],"meta":{"line":23,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"directory","description":"Directory to modules.","readonly":true,"type":[[["string"]]],"meta":{"line":30,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"classToHandle","description":"Class to handle.","readonly":true,"type":[[["function"]]],"meta":{"line":37,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"modules","description":"Modules loaded, mapped by ID to AkairoModule.","type":[[["Collection","<"],["string",", "],["AkairoModule",">"]]],"meta":{"line":60,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"categories","description":"Categories, mapped by ID to Category.","type":[[["Collection","<"],["string",", "],["Category",">"]]],"meta":{"line":66,"file":"AkairoHandler.js","path":"src/struct"}}],"methods":[{"name":"test","description":"Tests inhibitors against the message.\nRejects with the reason if blocked.","params":[{"name":"type","description":"Type of inhibitor, 'all', 'pre', or 'post'.","type":[[["string"]]]},{"name":"message","description":"Message to test.","type":[[["Message"]]]},{"name":"command","description":"Command to use.","optional":true,"type":[[["Command"]]]}],"returns":[[["Promise","<"],["Array","<"],["void",">>"]]],"meta":{"line":36,"file":"InhibitorHandler.js","path":"src/struct"}},{"name":"loadAll","description":"Reads all modules from the directory and loads them.","inherits":"AkairoHandler#loadAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":73,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"_apply","description":"Registers a module.","access":"private","inherits":"AkairoHandler#_apply","inherited":true,"params":[{"name":"mod","description":"Module to use.","type":[[["AkairoModule"]]]},{"name":"filepath","description":"Filepath of module.","optional":true,"type":[[["string"]]]}],"returns":[[["void"]]],"meta":{"line":86,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"_unapply","description":"Deregisters a module.","access":"private","inherits":"AkairoHandler#_unapply","inherited":true,"params":[{"name":"mod","description":"Module to use.","type":[[["AkairoModule"]]]}],"returns":[[["void"]]],"meta":{"line":118,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"load","description":"Loads a module, can be a filepath or an object.","inherits":"AkairoHandler#load","inherited":true,"params":[{"name":"thing","description":"Module or path to module.","type":[[["string"]],[["AkairoModule"]]]},{"name":"isReload","description":"Whether this is a reload or not.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":130,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"add","description":"Adds a module.","inherits":"AkairoHandler#add","inherited":true,"deprecated":"Use AkairoHandler#load","params":[{"name":"filename","description":"Filename to lookup in the directory.\nA .js extension is assumed.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":169,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"remove","description":"Removes a module.","inherits":"AkairoHandler#remove","inherited":true,"params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":185,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"removeAll","description":"Removes all modules.","inherits":"AkairoHandler#removeAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":199,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reload","description":"Reloads a module.","inherits":"AkairoHandler#reload","inherited":true,"params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":212,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reloadAll","description":"Reloads all modules.","inherits":"AkairoHandler#reloadAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":230,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"findCategory","description":"Finds a category by name.","inherits":"AkairoHandler#findCategory","inherited":true,"params":[{"name":"name","description":"Name to find with.","type":[[["string"]]]}],"returns":[[["Category"]]],"meta":{"line":243,"file":"AkairoHandler.js","path":"src/struct"}}],"events":[{"name":"load","description":"Emitted when an inhibitor is loaded.","params":[{"name":"inhibitor","description":"Inhibitor loaded.","type":[[["Inhibitor"]]]}],"meta":{"line":143,"file":"InhibitorHandler.js","path":"src/struct"}},{"name":"add","description":"Emitted when an inhibitor is added.","params":[{"name":"inhibitor","description":"Inhibitor added.","type":[[["Inhibitor"]]]}],"meta":{"line":149,"file":"InhibitorHandler.js","path":"src/struct"}},{"name":"remove","description":"Emitted when an inhibitor is removed.","params":[{"name":"inhibitor","description":"Inhibitor removed.","type":[[["Inhibitor"]]]}],"meta":{"line":155,"file":"InhibitorHandler.js","path":"src/struct"}},{"name":"reload","description":"Emitted when an inhibitor is reloaded.","params":[{"name":"inhibitor","description":"Inhibitor reloaded.","type":[[["Inhibitor"]]]}],"meta":{"line":161,"file":"InhibitorHandler.js","path":"src/struct"}},{"name":"enable","description":"Emitted when an inhibitor is enabled.","params":[{"name":"inhibitor","description":"Inhibitor enabled.","type":[[["Inhibitor"]]]}],"meta":{"line":167,"file":"InhibitorHandler.js","path":"src/struct"}},{"name":"disable","description":"Emitted when an inhibitor is disabled.","params":[{"name":"inhibitor","description":"Inhibitor disabled.","type":[[["Inhibitor"]]]}],"meta":{"line":173,"file":"InhibitorHandler.js","path":"src/struct"}}],"meta":{"line":10,"file":"InhibitorHandler.js","path":"src/struct"}},{"name":"Listener","description":"Represents a listener.","extends":["AkairoModule"],"construct":{"name":"Listener","params":[{"name":"id","description":"Listener ID.","type":[[["string"]]]},{"name":"exec","description":"The function called when event emitted.","type":[[["ListenerExecFunction"]]]},{"name":"options","description":"Options for the listener.","optional":true,"default":"{}","type":[[["ListenerOptions"]]]}]},"props":[{"name":"emitter","description":"The event emitter.","type":[[["string"]],[["EventEmitter"]]],"meta":{"line":23,"file":"Listener.js","path":"src/struct"}},{"name":"eventName","description":"The event name listened to.","type":[[["string"]]],"meta":{"line":29,"file":"Listener.js","path":"src/struct"}},{"name":"type","description":"Type of listener.","type":[[["string"]]],"meta":{"line":35,"file":"Listener.js","path":"src/struct"}},{"name":"id","description":"ID of the module.","type":[[["string"]]],"meta":{"line":20,"file":"AkairoModule.js","path":"src/struct"}},{"name":"category","description":"Category this belongs to.","type":[[["Category"]]],"meta":{"line":26,"file":"AkairoModule.js","path":"src/struct"}},{"name":"enabled","description":"Whether or not this is enabled.","type":[[["boolean"]]],"meta":{"line":32,"file":"AkairoModule.js","path":"src/struct"}},{"name":"filepath","description":"The filepath.","readonly":true,"type":[[["string"]]],"meta":{"line":39,"file":"AkairoModule.js","path":"src/struct"}},{"name":"client","description":"The Akairo client.","readonly":true,"type":[[["AkairoClient"]]],"meta":{"line":46,"file":"AkairoModule.js","path":"src/struct"}},{"name":"handler","description":"The handler.","readonly":true,"type":[[["AkairoHandler"]]],"meta":{"line":53,"file":"AkairoModule.js","path":"src/struct"}}],"methods":[{"name":"exec","description":"Executes the listener.","params":[{"name":"args","description":"Arguments.","optional":true,"variable":true,"type":[[["args"]]]}],"returns":[[["any"]]],"meta":{"line":37,"file":"Listener.js","path":"src/struct"}},{"name":"enable","description":"Enables the listener.","returns":[[["boolean"]]],"meta":{"line":64,"file":"Listener.js","path":"src/struct"}},{"name":"disable","description":"Disables the listener.","returns":[[["boolean"]]],"meta":{"line":74,"file":"Listener.js","path":"src/struct"}},{"name":"reload","description":"Reloads the module.","inherits":"AkairoModule#reload","inherited":true,"returns":[[["AkairoModule"]]],"meta":{"line":68,"file":"AkairoModule.js","path":"src/struct"}},{"name":"remove","description":"Removes the module.","inherits":"AkairoModule#remove","inherited":true,"returns":[[["AkairoModule"]]],"meta":{"line":76,"file":"AkairoModule.js","path":"src/struct"}},{"name":"toString","description":"Returns the ID.","inherits":"AkairoModule#toString","inherited":true,"returns":[[["string"]]],"meta":{"line":106,"file":"AkairoModule.js","path":"src/struct"}}],"meta":{"line":10,"file":"Listener.js","path":"src/struct"}},{"name":"ListenerHandler","description":"Loads listeners and registers them with EventEmitters.","extends":["AkairoHandler"],"construct":{"name":"ListenerHandler","params":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]]},{"name":"options","description":"Options from client.","type":[[["Object"]]]}]},"props":[{"name":"emitters","description":"EventEmitters for use, mapped by name to EventEmitter.\nBy default, 'client', 'commandHandler', 'inhibitorHandler', 'listenerHandler' are set.\nDatabases added through the client are also added here.","type":[[["Collection","<"],["string",", "],["EventEmitter",">"]]],"meta":{"line":22,"file":"ListenerHandler.js","path":"src/struct"}},{"name":"client","description":"The Akairo client.","readonly":true,"type":[[["AkairoClient"]]],"meta":{"line":23,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"directory","description":"Directory to modules.","readonly":true,"type":[[["string"]]],"meta":{"line":30,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"classToHandle","description":"Class to handle.","readonly":true,"type":[[["function"]]],"meta":{"line":37,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"modules","description":"Modules loaded, mapped by ID to AkairoModule.","type":[[["Collection","<"],["string",", "],["AkairoModule",">"]]],"meta":{"line":60,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"categories","description":"Categories, mapped by ID to Category.","type":[[["Collection","<"],["string",", "],["Category",">"]]],"meta":{"line":66,"file":"AkairoHandler.js","path":"src/struct"}}],"methods":[{"name":"_apply","description":"Registers a module.","access":"private","params":[{"name":"listener","description":"Module to use.","type":[[["Listener"]]]},{"name":"filepath","description":"Filepath of module.","optional":true,"type":[[["string"]]]}],"returns":[[["void"]]],"meta":{"line":56,"file":"ListenerHandler.js","path":"src/struct"}},{"name":"_unapply","description":"Deregisters a module.","access":"private","params":[{"name":"listener","description":"Module to use.","type":[[["Listener"]]]}],"returns":[[["void"]]],"meta":{"line":68,"file":"ListenerHandler.js","path":"src/struct"}},{"name":"register","description":"Adds a listener to the EventEmitter.","params":[{"name":"id","description":"ID of the listener.","type":[[["string"]]]}],"returns":[[["Listener"]]],"meta":{"line":78,"file":"ListenerHandler.js","path":"src/struct"}},{"name":"deregister","description":"Removes a listener from the EventEmitter.","params":[{"name":"id","description":"ID of the listener.","type":[[["string"]]]}],"returns":[[["Listener"]]],"meta":{"line":99,"file":"ListenerHandler.js","path":"src/struct"}},{"name":"loadAll","description":"Reads all modules from the directory and loads them.","inherits":"AkairoHandler#loadAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":73,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"load","description":"Loads a module, can be a filepath or an object.","inherits":"AkairoHandler#load","inherited":true,"params":[{"name":"thing","description":"Module or path to module.","type":[[["string"]],[["AkairoModule"]]]},{"name":"isReload","description":"Whether this is a reload or not.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":130,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"add","description":"Adds a module.","inherits":"AkairoHandler#add","inherited":true,"deprecated":"Use AkairoHandler#load","params":[{"name":"filename","description":"Filename to lookup in the directory.\nA .js extension is assumed.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":169,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"remove","description":"Removes a module.","inherits":"AkairoHandler#remove","inherited":true,"params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":185,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"removeAll","description":"Removes all modules.","inherits":"AkairoHandler#removeAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":199,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reload","description":"Reloads a module.","inherits":"AkairoHandler#reload","inherited":true,"params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":212,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reloadAll","description":"Reloads all modules.","inherits":"AkairoHandler#reloadAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":230,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"findCategory","description":"Finds a category by name.","inherits":"AkairoHandler#findCategory","inherited":true,"params":[{"name":"name","description":"Name to find with.","type":[[["string"]]]}],"returns":[[["Category"]]],"meta":{"line":243,"file":"AkairoHandler.js","path":"src/struct"}}],"events":[{"name":"load","description":"Emitted when a listener is loaded.","params":[{"name":"listener","description":"Listener loaded.","type":[[["Listener"]]]}],"meta":{"line":167,"file":"ListenerHandler.js","path":"src/struct"}},{"name":"add","description":"Emitted when a listener is added.","params":[{"name":"listener","description":"Listener added.","type":[[["Listener"]]]}],"meta":{"line":173,"file":"ListenerHandler.js","path":"src/struct"}},{"name":"remove","description":"Emitted when a listener is removed.","params":[{"name":"listener","description":"Listener removed.","type":[[["Listener"]]]}],"meta":{"line":179,"file":"ListenerHandler.js","path":"src/struct"}},{"name":"reload","description":"Emitted when a listener is reloaded.","params":[{"name":"listener","description":"Listener reloaded.","type":[[["Listener"]]]}],"meta":{"line":185,"file":"ListenerHandler.js","path":"src/struct"}},{"name":"enable","description":"Emitted when a listener is enabled.","params":[{"name":"listener","description":"Listener enabled.","type":[[["Listener"]]]}],"meta":{"line":191,"file":"ListenerHandler.js","path":"src/struct"}},{"name":"disable","description":"Emitted when a listener is disabled.","params":[{"name":"listener","description":"Listener disabled.","type":[[["Listener"]]]}],"meta":{"line":197,"file":"ListenerHandler.js","path":"src/struct"}}],"meta":{"line":12,"file":"ListenerHandler.js","path":"src/struct"}},{"name":"SQLiteHandler","description":"Creates an SQLiteHandler.\nTables must have an 'id' column.","extends":["EventEmitter"],"deprecated":"Use SQLiteProvider","construct":{"name":"SQLiteHandler","params":[{"name":"filepath","description":"Path to .sqlite file.","type":[[["string"]]]},{"name":"options","description":"Options for the handler.","optional":true,"default":"{}","type":[[["SQLiteOptions"]]]}]},"props":[{"name":"filepath","description":"Path to the database file.","type":[[["string"]]],"meta":{"line":26,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"tableName","description":"Name of the table.","type":[[["string"]]],"meta":{"line":32,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"defaultConfig","description":"Default configuration.","type":[[["Object"]]],"meta":{"line":38,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"json","description":"Keys to parse and stringify as JSON.","type":[[["Array","<"],["string",">"]]],"meta":{"line":44,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"db","description":"The database.","type":[[["Database"]]],"meta":{"line":50,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"memory","description":"Configurations stored in memory, mapped by ID to configuration.","type":[[["Collection","<"],["string",", "],["Object",">"]]],"meta":{"line":56,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"ids","description":"Array of IDs.\nNote that this calls the Collection's `keyArray()`.","type":[[["Array","<"],["string",">"]]],"meta":{"line":79,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"configs","description":"Array of configs.\nNote that this calls the Collection's `array()`.\nValues from here should be desanitized.","type":[[["Array","<"],["Object",">"]]],"meta":{"line":89,"file":"SQLiteHandler.js","path":"src/struct"}}],"methods":[{"name":"init","description":"Returns an array of IDs.","params":[{"name":"client","description":"Client to use.","type":[[["AkairoClient"]]]}],"returns":[[["Array","<"],["string",">"]]],"meta":{"line":64,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"sanitize","description":"Sanitizes a string by replacing single quotes with two single quotes.\nCan return a non-string if `json` is set to false.","params":[{"name":"input","description":"Input text.","type":[[["string"]]]},{"name":"json","description":"Whether to stringify or not.","default":false,"type":[[["boolean"]]]}],"returns":[[["any"]]],"meta":{"line":100,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"desanitize","description":"Desanitizes a string for use by replacing two single quotes with a single quote.\nCan return a non-string if `json` is set to true.","params":[{"name":"input","description":"Input text.","type":[[["string"]]]},{"name":"json","description":"Whether to parse or not.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["any"]]],"meta":{"line":113,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"open","description":"Opens the database so that it can be used.","returns":[[["Promise","<"],["Database",">"]]],"meta":{"line":123,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"load","description":"Loads handler and database with IDs.\nUse manually if you want to load database before client is ready.","params":[{"name":"ids","description":"Array of IDs.","type":[[["Array","<"],["string",">"]]]}],"returns":[[["Promise","<"],["SQLiteHandler",">"]]],"meta":{"line":136,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"add","description":"Adds into the database.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]}],"returns":[[["Promise","<"],["SQLiteHandler",">"]]],"meta":{"line":163,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"addMemory","description":"Adds into the in-memory config.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]}],"returns":[[["SQLiteHandler"]]],"meta":{"line":185,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"remove","description":"Removes from the database.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]}],"returns":[[["Promise","<"],["SQLiteHandler",">"]]],"meta":{"line":203,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"removeMemory","description":"Removes from the in-memory config.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]}],"returns":[[["SQLiteHandler"]]],"meta":{"line":221,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"has","description":"Checks if ID exists in config.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]}],"returns":[[["boolean"]]],"meta":{"line":235,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"get","description":"Gets configuration for an ID.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"keys","description":"Specific keys to get.\nLeave blank to get the entire configuration.","optional":true,"type":[[["Array","<"],["string",">"]]]}],"returns":[[["Object"]]],"meta":{"line":247,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"set","description":"Updates the database.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"Key to set.","type":[[["string"]]]},{"name":"value","description":"Value to set.","type":[[["string"]],[["number"]]]}],"returns":[[["Promise","<"],["SQLiteHandler",">"]]],"meta":{"line":277,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"setMemory","description":"Updates the in-memory configuration.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"Key to set.","type":[[["string"]]]},{"name":"value","description":"Value to set.","type":[[["string"]],[["number"]]]}],"returns":[[["SQLiteHandler"]]],"meta":{"line":311,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"save","description":"Saves an in-memory config to the database.","params":[{"name":"id","description":"ID to save.","type":[[["string"]]]}],"returns":[[["Promise","<"],["SQLiteHandler",">"]]],"meta":{"line":334,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"saveAll","description":"Saves all in-memory configs to the database.","returns":[[["Promise","<"],["SQLiteHandler",">"]]],"meta":{"line":378,"file":"SQLiteHandler.js","path":"src/struct"}}],"events":[{"name":"init","description":"Emitted when the handler is initalized.","meta":{"line":391,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"add","description":"Emitted when a config is added.","params":[{"name":"config","description":"Config added.","type":[[["Object"]]]},{"name":"memory","description":"Whether or not this was done in memory only.","type":[[["boolean"]]]}],"meta":{"line":396,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"remove","description":"Emitted when an ID is removed.","params":[{"name":"id","description":"ID removed.","type":[[["string"]]]},{"name":"memory","description":"Whether or not this was done in memory only.","type":[[["boolean"]]]}],"meta":{"line":403,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"set","description":"Emitted when something was set.","params":[{"name":"config","description":"Config that changed.","type":[[["Object"]]]},{"name":"memory","description":"Whether or not this was done in memory only.","type":[[["boolean"]]]}],"meta":{"line":410,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"save","description":"Emitted when a config was saved from memory.","params":[{"name":"config","description":"Config that was saved.","type":[[["Object"]]]},{"name":"newInsert","description":"Whether or not the config has been in the database before.","type":[[["boolean"]]]}],"meta":{"line":417,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"saveAll","description":"Emitted when many configs were saved from memory.","meta":{"line":424,"file":"SQLiteHandler.js","path":"src/struct"}}],"meta":{"line":16,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"TypeResolver","description":"Type resolver for command arguments.\nThe types are documented under ArgumentType.","construct":{"name":"TypeResolver","params":[{"name":"handler","description":"The command handler.","type":[[["CommandHandler"]]]}]},"props":[{"name":"client","description":"The Akairo client.","readonly":true,"type":[[["AkairoClient"]]],"meta":{"line":12,"file":"TypeResolver.js","path":"src/struct"}},{"name":"handler","description":"The command handler.","type":[[["CommandHandler"]]],"meta":{"line":26,"file":"TypeResolver.js","path":"src/struct"}}],"methods":[{"name":"type","description":"Gets the resolver function for a type.","params":[{"name":"name","description":"Name of type.","type":[[["string"]]]}],"returns":[[["function"]]],"meta":{"line":312,"file":"TypeResolver.js","path":"src/struct"}},{"name":"addType","description":"Adds a new type.","params":[{"name":"name","description":"Name of the type.","type":[[["string"]]]},{"name":"resolver","description":"Function that resolves the type.","type":[[["ArgumentTypeFunction"]]]}],"returns":[[["TypeResolver"]]],"meta":{"line":322,"file":"TypeResolver.js","path":"src/struct"}},{"name":"addTypes","description":"Adds multiple new types.","params":[{"name":"types","description":"Object with keys as the type name and values as the resolver function.","type":[[["Object"]]]}],"returns":[[["TypeResolver"]]],"meta":{"line":337,"file":"TypeResolver.js","path":"src/struct"}}],"meta":{"line":10,"file":"TypeResolver.js","path":"src/struct"}},{"name":"Category","description":"A group of modules.","extends":["Collection"],"construct":{"name":"Category","params":[{"name":"id","description":"ID of the category.","type":[[["string"]]]},{"name":"iterable","description":"Entries to set.","optional":true,"type":[[["Iterable"]]]}]},"props":[{"name":"id","description":"ID of the category.","type":[[["string"]]],"meta":{"line":17,"file":"Category.js","path":"src/util"}}],"methods":[{"name":"reloadAll","description":"Calls `reload()` on all items in this category.","returns":[[["Category"]]],"meta":{"line":24,"file":"Category.js","path":"src/util"}},{"name":"removeAll","description":"Calls `remove()` on all items in this category.","returns":[[["Category"]]],"meta":{"line":36,"file":"Category.js","path":"src/util"}},{"name":"enableAll","description":"Calls `enable()` on all items in this category.","returns":[[["Category"]]],"meta":{"line":48,"file":"Category.js","path":"src/util"}},{"name":"disableAll","description":"Calls `disable()` on all items in this category.","returns":[[["Category"]]],"meta":{"line":57,"file":"Category.js","path":"src/util"}},{"name":"toString","description":"Returns the ID.","returns":[[["string"]]],"meta":{"line":66,"file":"Category.js","path":"src/util"}}],"meta":{"line":9,"file":"Category.js","path":"src/util"}}],"interfaces":[],"typedefs":[{"name":"ProviderOptions","description":"Options to use for providers.","type":[[["Object"]]],"props":[{"name":"idColumn","description":"Column for the unique key, defaults to 'id'.","optional":true,"default":"'id'","type":[[["string"]]]},{"name":"dataColumn","description":"Column for JSON data.\nIf not provided, the provider will use all columns of the table.\nIf provided, only one column will be used, but it will be more flexible due to being parsed as JSON.\nFor Sequelize, note that the model has to specify the type of the column as JSON or JSONB.","optional":true,"type":[[["string"]]]}],"meta":{"line":73,"file":"Provider.js","path":"src/providers"}},{"name":"AkairoOptions","description":"Options used to determine how the framework behaves.","type":[[["Object"]]],"props":[{"name":"ownerID","description":"Discord ID of the client owner(s).","optional":true,"default":"''","type":[[["string"]],[["Array","<"],["string",">"]]]},{"name":"selfbot","description":"Whether or not this bot is a selfbot.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"commandDirectory","description":"Directory to commands.","optional":true,"type":[[["string"]]]},{"name":"prefix","description":"Default command prefix(es).","optional":true,"default":"'!'","type":[[["string"]],[["Array","<"],["string",">"]],[["PrefixFunction"]]]},{"name":"allowMention","description":"Whether or not to allow mentions to the client user as a prefix.","optional":true,"default":true,"type":[[["boolean"]],[["AllowMentionFunction"]]]},{"name":"handleEdits","description":"Whether or not to handle edited messages.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"commandUtil","description":"Whether or not to assign `message.util`.\nSet to `true` by default if `handleEdits` is on.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"commandUtilLifetime","description":"Milliseconds a command util should last before it is removed.\nIf 0, command utils will never be removed.","optional":true,"default":0,"type":[[["number"]]]},{"name":"fetchMembers","description":"Whether or not to fetch member on each message from a guild.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"defaultCooldown","description":"The default cooldown for commands.","optional":true,"default":0,"type":[[["number"]]]},{"name":"defaultPrompt","description":"The default prompt options.","optional":true,"type":[[["ArgumentPromptOptions"]]]},{"name":"inhibitorDirectory","description":"Directory to inhibitors.","optional":true,"type":[[["string"]]]},{"name":"blockNotSelf","description":"Whether or not to block others, if a selfbot.","optional":true,"default":true,"type":[[["boolean"]]]},{"name":"blockClient","description":"Whether or not to block self, if not a selfbot.","optional":true,"default":true,"type":[[["boolean"]]]},{"name":"blockBots","description":"Whether or not to block bots.","optional":true,"default":true,"type":[[["boolean"]]]},{"name":"listenerDirectory","description":"Directory to listeners.","optional":true,"type":[[["string"]]]},{"name":"emitters","description":"Emitters to load onto the listener handler.","optional":true,"default":"{}","type":[[["Object"]]]},{"name":"automateCategories","description":"Whether or not to set each module's category to it's parent directory name","optional":true,"default":false,"type":[[["boolean"]]]}],"meta":{"line":183,"file":"AkairoClient.js","path":"src/struct"}},{"name":"PrefixFunction","description":"A function that returns the prefix(es) to use.","type":[[["function"]]],"params":[{"name":"message","description":"Message to get prefix for.","type":[[["Message"]]]}],"returns":[[["string"]],[["Array","<"],["string",">"]]],"meta":{"line":208,"file":"AkairoClient.js","path":"src/struct"}},{"name":"AllowMentionFunction","description":"A function that returns whether mentions can be used as a prefix.","type":[[["function"]]],"params":[{"name":"message","description":"Message to option for.","type":[[["Message"]]]}],"returns":[[["boolean"]]],"meta":{"line":215,"file":"AkairoClient.js","path":"src/struct"}},{"name":"ModuleOptions","description":"Options for module.","type":[[["Object"]]],"props":[{"name":"category","description":"Category ID for organization purposes.","optional":true,"default":"'default'","type":[[["string"]]]}],"meta":{"line":113,"file":"AkairoModule.js","path":"src/struct"}},{"name":"ModuleExecFunction","description":"The module's execution function.","type":[[["function"]]],"params":[{"name":"args","description":"Arguments.","variable":true,"type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":119,"file":"AkairoModule.js","path":"src/struct"}},{"name":"MessageOptionsExtensions","description":"Extra properties alongside the Discord.js message options type.\nAvailable for use when returning in a prompt function or in CommandUtil.","type":[[["Object"]]],"props":[{"name":"content","description":"Content to send.","optional":true,"type":[[["string"]],[["Array","<"],["string",">"]]]}],"meta":{"line":282,"file":"Argument.js","path":"src/struct"}},{"name":"ArgumentMatch","description":"The method to match arguments from text.\n- `word` matches by the order of the words inputted.\nIt ignores words that matches a prefix or a flag.\n- `rest` matches the rest of the words in order.\nIt ignores words that matches a prefix or a flag.\n- `prefix` matches words that starts with the prefix.\nThe word after the prefix is the evaluated argument.\n- `flag` matches words that are the same as its prefix.\nThe evaluated argument is either true or false.\n- `text` matches the entire text, except for the command.\nIt ignores words that matches a prefix or a flag.\n- `content` matches the entire text as it was inputted, except for the command.\n- `none` matches nothing at all and an empty string will be used for type operations.","type":[[["string"]]],"meta":{"line":289,"file":"Argument.js","path":"src/struct"}},{"name":"ArgumentMatchFunction","description":"A function returning a method to match arguments.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"prevArgs","description":"Previous arguments.","type":[[["Object"]]]}],"returns":[[["ArgumentMatch"]]],"meta":{"line":306,"file":"Argument.js","path":"src/struct"}},{"name":"ArgumentType","description":"The type that the argument should be cast to.\n- `string` does not cast to any type.\n- `lowercase` makes the input lowercase.\n- `uppercase` makes the input uppercase.\n- `charCodes` transforms the input to an array of char codes.\n- `number` casts to an number with `parseFloat()`.\n- `integer` casts to an integer with `parseInt()`.\n- `dynamic` casts to a number with `parseFloat()` or a trimmed input if not a number.\n- `dynamicInt` casts to an integer with `parseInt()` or a trimmed input if not a number.\n- `url` casts to an `URL` object.\n- `date` casts to a `Date` object.\n- `color` casts a hex code to an integer.\n- `commandAlias` tries to resolve to a command from an alias.\n- `command` matches the ID of a command.\n- `inhibitor` matches the ID of an inhibitor.\n- `listener` matches the ID of a listener.\n\nPossible Discord-related types.\nThese types can be plural (add an 's' to the end) and a collection of matching objects will be used.\n- `user` tries to resolve to a user.\n- `member` tries to resolve to a member.\n- `relevant` tries to resolve to a relevant user, works in both guilds and DMs.\n- `channel` tries to resolve to a channel.\n- `textChannel` tries to resolve to a text channel.\n- `voiceChannel` tries to resolve to a voice channel.\n- `role` tries to resolve to a role.\n- `emoji` tries to resolve to a custom emoji.\n- `guild` tries to resolve to a guild.\n\nOther Discord-related types:\n- `message` tries to fetch a message from an ID.\n- `invite` tries to resolve an invite code from a link.\n- `memberMention` matches a mention of a guild member.\n- `channelMention` matches a mention of a channel.\n- `roleMention` matches a mention of a role.\n- `emojiMention` matches a mention of an emoji.\n\nAn array of strings can be used to restrict input to only those strings, case insensitive.\nThe array can also contain an inner array of strings, for aliases.\nIf so, the first entry of the array will be used as the final argument.\n\nA regular expression can also be used.\nThe evaluated argument will be an object containing the `match` and `groups` if global.","type":[[["string"]],[["Array","<"],["string",">"]]],"meta":{"line":314,"file":"Argument.js","path":"src/struct"}},{"name":"ArgumentTypeFunction","description":"A function for processing user input to use as an argument.\nA return value of `true` will let the word pass.\nA `null` or `undefined` return value will use the default value for the argument or start a prompt.\nAny other truthy return value will be used as the evaluated argument.\nIf returning a Promise, the value resolved will be the argument.\nA rejection will use the default value or start a prompt.","type":[[["function"]]],"params":[{"name":"word","description":"The user input.","type":[[["string"]]]},{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"prevArgs","description":"Previous arguments.","type":[[["Object"]]]}],"returns":[[["any"]]],"meta":{"line":361,"file":"Argument.js","path":"src/struct"}},{"name":"ArgumentPromptOptions","description":"A prompt to run if the user did not input the argument correctly.\nCan only be used if there is not a default value (unless optional is true).","type":[[["Object"]]],"props":[{"name":"retries","description":"Amount of times allowed to retries.","optional":true,"default":1,"type":[[["number"]]]},{"name":"time","description":"Time to wait for input.","optional":true,"default":30000,"type":[[["number"]]]},{"name":"cancelWord","description":"Word to use for cancelling the command.","optional":true,"default":"'cancel'","type":[[["string"]]]},{"name":"stopWord","description":"Word to use for ending infinite prompts.","optional":true,"default":"'stop'","type":[[["string"]]]},{"name":"optional","description":"Prompts only when argument is provided but was not of the right type.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"infinite","description":"Prompts forever until the stop word, cancel word, time limit, or retry limit.\nNote that the retry count resets back to one on each valid entry.\nThe final evaluated argument will be an array of the inputs.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"limit","description":"Amount of inputs allowed for an infinite prompt before finishing.","optional":true,"default":"Infinite","type":[[["number"]]]},{"name":"start","description":"Text sent on start of prompt.","optional":true,"type":[[["string"]],[["Array","<"],["string",">"]],[["ArgumentPromptFunction"]]]},{"name":"retry","description":"Text sent on a retry (failure to cast type).","optional":true,"type":[[["string"]],[["Array","<"],["string",">"]],[["ArgumentPromptFunction"]]]},{"name":"timeout","description":"Text sent on collector time out.","optional":true,"type":[[["string"]],[["Array","<"],["string",">"]],[["ArgumentPromptFunction"]]]},{"name":"ended","description":"Text sent on amount of tries reaching the max.","optional":true,"type":[[["string"]],[["Array","<"],["string",">"]],[["ArgumentPromptFunction"]]]},{"name":"cancel","description":"Text sent on cancellation of command.","optional":true,"type":[[["string"]],[["Array","<"],["string",">"]],[["ArgumentPromptFunction"]]]}],"meta":{"line":375,"file":"Argument.js","path":"src/struct"}},{"name":"ArgumentPromptFunction","description":"A function returning text for the prompt or a `MessageOptions` object.\nThe options can have an extra optional property called `content` for message content.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"prevArgs","description":"Previous arguments.","type":[[["Object"]]]},{"name":"tries","description":"The amount of tries the user has taken.","type":[[["number"]]]}],"returns":[[["string"]],[["Array","<"],["string",">"]],[["MessageOptions"]]],"meta":{"line":395,"file":"Argument.js","path":"src/struct"}},{"name":"ArgumentOptions","description":"Options for how an argument parses text.","type":[[["Object"]]],"props":[{"name":"id","description":"ID of the argument for use in the args object.","type":[[["string"]]]},{"name":"match","description":"Method to match text.","optional":true,"default":"'word'","type":[[["ArgumentMatch"]],[["ArgumentMatchFunction"]]]},{"name":"type","description":"Type to cast to.","optional":true,"default":"'string'","type":[[["ArgumentType"]],[["ArgumentTypeFunction"]]]},{"name":"prefix","description":"The string(s) to use as the flag for prefix and flag args.","optional":true,"type":[[["string"]],[["Array","<"],["string",">"]]]},{"name":"index","description":"Index/word of text to start from.\nApplicable to word, text, or content match only.","optional":true,"type":[[["number"]]]},{"name":"default","description":"Default value if text does not parse or cast correctly.\nIf using a flag arg, setting the default value inverses the result.","optional":true,"default":"''","type":[[["any"]],[["ArgumentDefaultFunction"]]]},{"name":"description","description":"A description of the argument.","optional":true,"default":"''","type":[[["string"]],[["Array","<"],["string",">"]]]},{"name":"prompt","description":"Prompt options for when user does not provide input.\nMust not have a default value for this to work.","optional":true,"type":[[["ArgumentPromptOptions"]]]}],"meta":{"line":405,"file":"Argument.js","path":"src/struct"}},{"name":"ArgumentDefaultFunction","description":"Function get the default value of the argument.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"prevArgs","description":"Previous arguments.","type":[[["Object"]]]}],"returns":[[["any"]]],"meta":{"line":421,"file":"Argument.js","path":"src/struct"}},{"name":"PromptCheckFunction","description":"Function used to check if a response should pass for the prompt.","type":[[["function"]]],"params":[{"name":"message","description":"Message to check.","type":[[["Message"]]]},{"name":"sent","description":"The prompt's sent message.","optional":true,"type":[[["Message"]]]}],"returns":[[["boolean"]]],"meta":{"line":560,"file":"ClientUtil.js","path":"src/struct"}},{"name":"CommandOptions","description":"Options to use for command execution behavior.","type":[[["Object"]]],"props":[{"name":"aliases","description":"Command names.","optional":true,"default":"[]","type":[[["Array","<"],["string",">"]]]},{"name":"args","description":"Arguments to parse.","optional":true,"default":"[]","type":[[["Array","<"],["ArgumentOptions",">"]]]},{"name":"split","description":"Method to split text into words.","optional":true,"default":"'plain'","type":[[["ArgumentSplit"]],[["ArgumentSplitFunction"]]]},{"name":"channelRestriction","description":"Restricts channel: 'guild' or 'dm'.","optional":true,"type":[[["string"]]]},{"name":"category","description":"Category ID for organization purposes.","optional":true,"default":"'default'","type":[[["string"]]]},{"name":"ownerOnly","description":"Whether or not to allow client owner(s) only.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"protected","description":"Whether or not this command cannot be disabled.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"typing","description":"Whether or not to type in channel during execution.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"editable","description":"Whether or not message edits will run this command.\nOn an edited message, the exec function edited param will be true.","optional":true,"default":true,"type":[[["boolean"]]]},{"name":"cooldown","description":"The command cooldown in milliseconds.","optional":true,"type":[[["number"]]]},{"name":"ratelimit","description":"Amount of command uses allowed until cooldown.","optional":true,"default":1,"type":[[["number"]]]},{"name":"prefix","description":"The prefix(es) to overwrite the global one for this command.","optional":true,"type":[[["string"]],[["Array","<"],["string",">"]],[["PrefixFunction"]]]},{"name":"userPermissions","description":"Permissions required by the user to run this command.","optional":true,"type":[[["PermissionResolvable"]],[["Array","<"],["PermissionResolvable",">"]],[["PermissionFunction"]]]},{"name":"clientPermissions","description":"Permissions required by the client to run this command.","optional":true,"type":[[["PermissionResolvable"]],[["Array","<"],["PermissionResolvable",">"]],[["PermissionFunction"]]]},{"name":"trigger","description":"A regex to match in messages that are NOT commands.\nThe exec function becomes `((message, match, groups, edited) => any)`.","optional":true,"type":[[["RegExp"]],[["TriggerFunction"]]]},{"name":"condition","description":"Whether or not to run on messages that are NOT commands.\nThe exec function becomes `((message, edited) => any)`.","optional":true,"type":[[["ConditionFunction"]]]},{"name":"defaultPrompt","description":"The default prompt options.","optional":true,"default":"{}","type":[[["ArgumentPromptOptions"]]]},{"name":"options","description":"An object for custom options.","optional":true,"default":"{}","type":[[["Object"]]]},{"name":"description","description":"Description of the command.","optional":true,"default":"''","type":[[["string"]],[["Array","<"],["string",">"]]]}],"meta":{"line":353,"file":"Command.js","path":"src/struct"}},{"name":"PermissionFunction","description":"A function used to check if a message has permissions for the command.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]}],"returns":[[["boolean"]]],"meta":{"line":380,"file":"Command.js","path":"src/struct"}},{"name":"TriggerFunction","description":"A function used to return a regular expression.","type":[[["function"]]],"params":[{"name":"message","description":"Message to get regex for.","type":[[["Message"]]]}],"returns":[[["RegExp"]]],"meta":{"line":387,"file":"Command.js","path":"src/struct"}},{"name":"ConditionFunction","description":"A function used to check if the command should run.","type":[[["function"]]],"params":[{"name":"message","description":"Message to check.","type":[[["Message"]]]}],"returns":[[["boolean"]]],"meta":{"line":394,"file":"Command.js","path":"src/struct"}},{"name":"ArgumentSplit","description":"The method to split text into words.\n- `plain` splits word separated by whitespace.\nExtra whitespace between words are ignored.\n- `split` splits word separated by whitespace.\nShould not be used due to possible inconsistent whitespace.\nDEPRECATED: no alternatives.\n- `quoted` is similar to plain, but counts text inside double quotes as one word.\n- `sticky` is similar to quoted, but makes it so that quoted text must have a whitespace or another double quote before it.\nThis means that `thing=\"hello world\"` would be one, rather than two like when using `quoted`.\n- `none` gives the entire content.\n\nIt is recommended that you use either `plain` or `sticky` for your commands.\n\nA regex or a character can be used instead (for example, a comma) to split the message by that regex or character.","type":[[["string"]],[["RegExp"]]],"meta":{"line":401,"file":"Command.js","path":"src/struct"}},{"name":"ArgumentSplitFunction","description":"A function that returns the words to use for the arguments.","type":[[["function"]]],"params":[{"name":"content","description":"The message content without the prefix and command.","type":[[["string"]]]},{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]}],"returns":[[["Array","<"],["string",">"]]],"meta":{"line":419,"file":"Command.js","path":"src/struct"}},{"name":"CommandExecFunction","description":"The command's execution function.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"args","description":"Evaluated arguments.","type":[[["Object"]]]},{"name":"edited","description":"Whether the user's message was edited.\nDEPRECATED: Use Messaged#edited.","type":[[["boolean"]]]}],"returns":[[["any"]]],"meta":{"line":427,"file":"Command.js","path":"src/struct"}},{"name":"RegexCommandExecFunction","description":"The command's execution function when triggered with a regex.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"match","description":"The results from `string.match()` with the regex.","type":[[["any"]]]},{"name":"groups","description":"The matched groups if a global regex.","type":[[["Array","<"],["string",">"]]]},{"name":"edited","description":"Whether the user's message was edited.\nDEPRECATED: Use Messaged#edited.","type":[[["boolean"]]]}],"returns":[[["any"]]],"meta":{"line":437,"file":"Command.js","path":"src/struct"}},{"name":"ConditionalCommandExecFunction","description":"The command's execution function when triggered with a condition.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"edited","description":"Whether the user's message was edited.\nDEPRECATED: Use Messaged#edited.","type":[[["boolean"]]]}],"returns":[[["any"]]],"meta":{"line":448,"file":"Command.js","path":"src/struct"}},{"name":"MessageExtensions","description":"Extra properties applied to the Discord.js message object.","type":[[["Object"]]],"props":[{"name":"util","description":"Utilities for command responding.\nAvailable on all messages after 'all' inhibitors and built-in inhibitors (bot, client, notSelf).\nNot all properties of the util are available, depending on the input.","nullable":true,"type":[[["CommandUtil"]]]}],"meta":{"line":179,"file":"CommandUtil.js","path":"src/struct"}},{"name":"InhibitorOptions","description":"Options to use for inhibitor execution behavior.","type":[[["Object"]]],"props":[{"name":"reason","description":"Reason emitted when command or message is blocked.","optional":true,"default":"''","type":[[["string"]]]},{"name":"type","description":"Can be 'all' to run on all messages, 'pre' to run on messages not blocked by the built-in inhibitors, or 'post' to run on messages that are commands.","optional":true,"default":"'post'","type":[[["boolean"]]]},{"name":"category","description":"Category ID for organization purposes.","optional":true,"default":"'default'","type":[[["string"]]]}],"meta":{"line":85,"file":"Inhibitor.js","path":"src/struct"}},{"name":"InhibitorExecFunction","description":"Function to check if message should be blocked.\nA return value of true or a rejecting Promise will block the message.","type":[[["function"]]],"params":[{"name":"message","description":"Message being handled.","type":[[["Message"]]]},{"name":"command","description":"Command to check.","optional":true,"type":[[["Command"]]]}],"returns":[[["boolean"]],[["Promise","<"],["any",">"]]],"meta":{"line":93,"file":"Inhibitor.js","path":"src/struct"}},{"name":"ListenerOptions","description":"Options to use for listener execution behavior.","type":[[["Object"]]],"props":[{"name":"emitter","description":"The event emitter, either a key from `ListenerHandler#emitters` or an EventEmitter.","optional":true,"default":"'client'","type":[[["string"]],[["EventEmitter"]]]},{"name":"eventName","description":"Event name to listen to.","optional":true,"default":"'ready'","type":[[["string"]]]},{"name":"type","description":"Type of listener, either 'on' or 'once'.","optional":true,"default":"'on'","type":[[["string"]]]},{"name":"category","description":"Category ID for organization purposes.","optional":true,"default":"'default'","type":[[["string"]]]}],"meta":{"line":97,"file":"Listener.js","path":"src/struct"}},{"name":"ListenerExecFunction","description":"Function called when event emitted.","type":[[["function"]]],"params":[{"name":"args","description":"Arguments.","optional":true,"variable":true,"type":[[["args"]]]}],"returns":[[["any"]]],"meta":{"line":106,"file":"Listener.js","path":"src/struct"}},{"name":"SQLiteOptions","description":"Options to use for the SQLiteHandler.","type":[[["Object"]]],"props":[{"name":"tablename","description":"Name of the table.","optional":true,"default":"'configs'","type":[[["string"]]]},{"name":"defaultConfig","description":"Default configuration.","optional":true,"default":"{}","type":[[["Object"]]]},{"name":"json","description":"Array of keys to parse and stringify as JSON.","optional":true,"default":"[]","type":[[["Array","<"],["string",">"]]]},{"name":"init","description":"IDs to use to initialize database.\nIf you want to load the database before login, use `SQLiteHandler#load`.","optional":true,"default":"[]","type":[[["Array","<"],["string",">"]],[["SQLiteInitFunction"]]]}],"meta":{"line":429,"file":"SQLiteHandler.js","path":"src/struct"}},{"name":"SQLiteInitFunction","description":"Function used to get IDs for database.","type":[[["function"]]],"params":[{"name":"client","description":"The client.","type":[[["AkairoClient"]]]}],"returns":[[["Array","<"],["string",">"]]],"meta":{"line":439,"file":"SQLiteHandler.js","path":"src/struct"}}],"externals":[]}